"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[1657],{53699:function(e,t,n){let r;n.d(t,{G_R:function(){return getParent},Hnr:function(){return Model},Nc9:function(){return draft},QbW:function(){return setGlobalConfig},RTE:function(){return tJ},UB4:function(){return ed},Xx3:function(){return applySnapshot},ZBq:function(){return modelAction},ZMl:function(){return tR},atr:function(){return fromSnapshot},cfB:function(){return onSnapshot},h8:function(){return timestampToDateTransform},jps:function(){return frozen},k0l:function(){return getRootStore},m83:function(){return isRootStore},o4J:function(){return model},oU$:function(){return findParent},ogt:function(){return detach},uNj:function(){return isModelDataObject},v5r:function(){return eH},vMv:function(){return getSnapshot},vgT:function(){return prop}});var o,a,l,i,s,c,u,d,p,h,f,y,m,b,g,v,w,T,S,O,_,k,C,P,I,M,j,A,D,F,x,N=n(68949),$=Object.defineProperty,__defNormalProp=(e,t,n)=>t in e?$(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,__publicField=(e,t,n)=>(__defNormalProp(e,"symbol"!=typeof t?t+"":t,n),n);let R=new Map;(o=O||(O={})).ApplyPatches="$$applyPatches",o.ApplySnapshot="$$applySnapshot",o.Detach="$$detach",o.ApplySet="$$applySet",o.ApplyDelete="$$applyDelete",o.ApplyMethodCall="$$applyMethodCall",Object.values(O),(a=_||(_={})).Sync="sync",a.Async="async",(l=k||(k={})).Spawn="spawn",l.Return="return",l.Resume="resume",l.ResumeError="resumeError",l.Throw="throw";let V=Symbol("modelAction");function isModelAction(e){return"function"==typeof e&&V in e}let z="$modelType",E="$modelId";let MobxKeystoneError=class MobxKeystoneError extends Error{constructor(e){super(e),Object.setPrototypeOf(this,MobxKeystoneError.prototype)}};function failure(e){return new MobxKeystoneError(e)}let G={enumerable:!1,writable:!0,configurable:!1,value:void 0};function addHiddenProp(e,t,n,r=!0){r?(Object.defineProperty(e,t,G),e[t]=n):Object.defineProperty(e,t,{enumerable:!1,writable:r,configurable:!0,value:n})}function isPlainObject(e){if(!isObject(e))return!1;let t=Object.getPrototypeOf(e);return t===Object.prototype||null===t}function isObject(e){return null!==e&&"object"==typeof e}function isPrimitive(e){switch(typeof e){case"number":case"string":case"boolean":case"undefined":case"bigint":return!0}return null===e}function isMap(e){return e instanceof Map||(0,N.isObservableMap)(e)}function isSet(e){return e instanceof Set||(0,N.isObservableSet)(e)}function isArray(e){return Array.isArray(e)||(0,N.isObservableArray)(e)}function assertIsObject(e,t){if(!isObject(e))throw failure(`${t} must be an object`)}function assertIsObservableArray(e,t){if(!(0,N.isObservableArray)(e))throw failure(`${t} must be an observable array`)}function assertIsFunction(e,t){if("function"!=typeof e)throw failure(`${t} must be a function`)}let U=Symbol("runAfterNew"),L=Symbol("runBeforeOnInit");function addLateInitializationFunction(e,t,n){let r=e[t];r&&Object.prototype.hasOwnProperty.call(e,t)||addHiddenProp(e,t,r=r?r.slice():[]),r.push(n)}let B=Symbol("unboundMethod");function runLateInitializationFunctions(e,t){let n=e[t];if(n)for(let t of n)t(e)}let W=new Set;function logWarning(e,t,n){if(n){if(W.has(n))return;W.add(n)}switch(t="[mobx-keystone] "+t,e){case"warn":console.warn(t);break;case"error":console.error(t);break;default:throw failure(`unknown log type - ${e}`)}}function lazy(e){let t;let n=!1;return(...r)=>(n||(t=e(...r),n=!0),t)}let identityFn=e=>e,J={makeObservable:N.makeObservable};function getMobxVersion(){return J.makeObservable?6:5}let Q="mobx-keystone",q=Symbol("propsType"),H=Symbol("fromSnapshotOverrideType"),K=Symbol("toSnapshotOverrideType"),X=Symbol("modelInitialized"),Y={},Z=new WeakMap;function getOrCreate(e,t,n){let r=e.get(t);return void 0===r&&(r=n(),e.set(t,r)),r}let ee=new WeakMap,et=new WeakMap;function createParentPathAtom(e){return getOrCreate(et,e,()=>(0,N.createAtom)("parentAtom"))}function reportParentPathChanged(e){createParentPathAtom(e).reportChanged()}let en=new WeakMap;function dataToModelNode(e){let t=en.get(e);return null!=t?t:e}function modelToDataNode(e){return isModel(e)?e.$:e}let er=new WeakMap;function isTweakedObject(e,t){return!(!t&&en.has(e))&&er.has(e)}function isTreeNode(e){return!isPrimitive(e)&&isTweakedObject(e,!1)}function assertTweakedObject(e,t,n=!1){if(!n&&en.has(e))throw failure(`${t} must be the model object instance instead of the '$' sub-object`);if(isPrimitive(e)||!isTweakedObject(e,!0))throw failure(`${t} must be a tree node (usually a model or a shallow / deep child part of a model 'data' object)`)}let eo=!1,ea=Symbol("modelMetadata"),el=Symbol("modelUnwrappedClass"),ei=Symbol("runAfterModelDecorator");function getModelMetadata(e){if(isModel(e))return e.constructor[ea];if(isModelClass(e))return e[ea];throw failure("modelClassOrInstance must be a model class or instance")}let es=new WeakMap;function getModelIdPropertyName(e){return getOrCreate(es,e,()=>getModelMetadata(e).modelIdProperty)}let ec=Symbol("modelProperties"),eu=Symbol("noDefaultValue"),ed={_setter:!1,_isId:!0,withSetter(e){let t=Object.create(this);return t._setter=null==e||e,t},typedAs:()=>ed},ep={_defaultFn:eu,_defaultValue:eu,_typeChecker:void 0,_setter:!1,_isId:!1,_transform:void 0,_fromSnapshotProcessor:void 0,_toSnapshotProcessor:void 0,withSetter(e){let t=Object.create(this);return t._setter=null==e||e,t},withTransform(e){let t=Object.create(this);return t._transform=function(e){let t=new WeakMap,transform=t=>null==t.originalValue?t.originalValue:e.transform(t),untransform=t=>null==t.transformedValue?t.transformedValue:e.untransform(t);return{transform(e,n,r,o){let a=getOrCreate(t,n,()=>new Map),l=a.get(r);(null==l?void 0:l.originalValue)!==e&&(a.delete(r),l=void 0);let i=transform({originalValue:e,cachedTransformedValue:null==l?void 0:l.transformedValue,setOriginalValue:o});return a.set(r,{originalValue:e,transformedValue:i}),i},untransform(e,n,r){let o=getOrCreate(t,n,()=>new Map);ef=!1;let a=untransform({transformedValue:e,cacheTransformedValue:cacheTransformedValueFn});return ef?o.set(r,{originalValue:a,transformedValue:e}):o.delete(r),a}}}(e),t},withSnapshotProcessor({fromSnapshot:e,toSnapshot:t}){let n,r;if(this._fromSnapshotProcessor&&e){let t=this._fromSnapshotProcessor;n=n=>t(e(n))}else n=e||this._fromSnapshotProcessor;if(this._toSnapshotProcessor&&t){let e=this._toSnapshotProcessor;r=n=>t(e(n))}else r=t||this._toSnapshotProcessor;let o=Object.create(this);return o._fromSnapshotProcessor=n,o._toSnapshotProcessor=r,o}};function prop(e){let t=arguments.length>=1;if(!t)return ep;let n=eh.get(e);return n||(n=Object.create(ep),"function"==typeof e?n._defaultFn=e:n._defaultValue=e,eh.set(e,n)),n}let eh=new Map,ef=!1,cacheTransformedValueFn=()=>{ef=!0};function getModelPropDefaultValue(e){return e._defaultFn!==eu?e._defaultFn():e._defaultValue!==eu?e._defaultValue:eu}let TypeCheckError=class TypeCheckError{constructor(e,t,n,r){__publicField(this,"path"),__publicField(this,"expectedTypeName"),__publicField(this,"actualValue"),__publicField(this,"typeCheckedValue"),__publicField(this,"message"),this.path=e,this.expectedTypeName=t,this.actualValue=n,this.typeCheckedValue=r;let o=[];this.typeCheckedValue&&isTweakedObject(this.typeCheckedValue,!0)&&(o=function(e){let t,n=e,r=[],o=[e];for(;t=fastGetParentPath(n);)n=t.parent,r.unshift(t.path),o.unshift(t.parent);return{root:n,path:r,pathObjects:o}}(this.typeCheckedValue).path);let a=isTweakedObject(this.actualValue,!0)?getSnapshot(this.actualValue):this.actualValue;this.message=`TypeCheckError: [/${[...o,...this.path].join("/")}] Expected a value of type <${this.expectedTypeName}> but got the value <${JSON.stringify(a)}> instead`}throw(){throw failure(this.message)}};let ey=[],em=new WeakMap;(i=C||(C={})).Object="object",i.Array="array",i.Primitive="primitive",i.Any="any";let eb=new WeakMap;let TypeChecker=class TypeChecker{constructor(e,t,n,r,o,a,l){__publicField(this,"baseType"),__publicField(this,"_check"),__publicField(this,"getTypeName"),__publicField(this,"typeInfoGen"),__publicField(this,"snapshotType"),__publicField(this,"_fromSnapshotProcessor"),__publicField(this,"_toSnapshotProcessor"),__publicField(this,"checkResultCache"),__publicField(this,"unchecked"),__publicField(this,"_cachedTypeInfoGen"),__publicField(this,"fromSnapshotProcessor",e=>this._fromSnapshotProcessor(e)),__publicField(this,"_toSnapshotProcessorCache",new WeakMap),__publicField(this,"toSnapshotProcessor",e=>{if("object"!=typeof e||null===e)return this._toSnapshotProcessor(e);if(this._toSnapshotProcessorCache.has(e))return this._toSnapshotProcessorCache.get(e);let t=this._toSnapshotProcessor(e);this._toSnapshotProcessorCache.set(e,t);let n=getOrCreate(eb,e,()=>new Set);return n.add(this),t}),this.baseType=e,this._check=t,this.getTypeName=n,this.typeInfoGen=r,this.snapshotType=o,this._fromSnapshotProcessor=a,this._toSnapshotProcessor=l,this.unchecked=!t,this._cachedTypeInfoGen=lazy(r)}createCacheIfNeeded(){return this.checkResultCache||(this.checkResultCache=new WeakMap),this.checkResultCache}setCachedResult(e,t){this.createCacheIfNeeded().set(e,t);let n=getOrCreate(em,e,()=>new Set);n.add(this)}invalidateCachedResult(e){var t;null==(t=this.checkResultCache)||t.delete(e)}getCachedResult(e){var t;return null==(t=this.checkResultCache)?void 0:t.get(e)}check(e,t,n){if(this.unchecked)return null;if(!isTweakedObject(e,!0))return this._check(e,t,n);let r=this.getCachedResult(e);return(void 0===r&&(r=this._check(e,ey,void 0),this.setCachedResult(e,r)),r)?new TypeCheckError([...t,...r.path],r.expectedTypeName,r.actualValue,n):null}get typeInfo(){return this._cachedTypeInfoGen(this)}invalidateSnapshotProcessorCachedResult(e){this._toSnapshotProcessorCache.delete(e)}};let eg=Symbol("lateTypeCheker");function lateTypeChecker(e,t){let n;let ltc=function(){return n||(n=e())};ltc[eg]=!0;let r=lazy(t);return Object.defineProperty(ltc,"typeInfo",{enumerable:!0,configurable:!0,get:()=>r(ltc)}),ltc}function isLateTypeChecker(e){return"function"==typeof e&&eg in e}let TypeInfo=class TypeInfo{constructor(e){__publicField(this,"thisType"),this.thisType=e}};function getTypeInfo(e){let t=resolveStandardType(e),n=t.typeInfo;if(!n)throw failure(`type info not found for ${e}`);return n}let ev=new WeakMap;function typesModel(e){if(!isModelClass(e)&&"function"==typeof e)return lateTypeChecker(()=>typesModel(e()),t=>new ModelTypeInfo(t,e()));{let t=ev.get(e);if(t)return t;let typeInfoGen=t=>new ModelTypeInfo(t,e),n=lateTypeChecker(()=>{let t=Z.get(e),n=`Model(${t.name})`,r=getModelMetadata(e).dataType,o=r?resolveTypeChecker(r):void 0,a=new TypeChecker(C.Object,(t,r,a)=>t instanceof e?o?o.check(t.$,r,a):null:new TypeCheckError(r,n,t,a),()=>n,typeInfoGen,e=>isObject(e)?void 0!==e[z]?e[z]===t.name?a:null:o&&o.snapshotType(e)?a:null:null,e=>e[z]?e:{...e,[z]:t.name},e=>e);return a},typeInfoGen);return ev.set(e,n),n}}let ModelTypeInfo=class ModelTypeInfo extends TypeInfo{constructor(e,t){super(e),__publicField(this,"modelClass"),__publicField(this,"_props",lazy(()=>{let e=this.modelClass[ec],t={};return Object.keys(e).forEach(n=>{let r,o;let a=e[n],l=a._typeChecker;l&&(r=getTypeInfo(l));let i=!1;a._defaultFn!==eu?(o=a._defaultFn,i=!0):a._defaultValue!==eu&&(o=a._defaultValue,i=!0),t[n]={type:l,typeInfo:r,hasDefault:i,default:o}}),t})),this.modelClass=t}get props(){return this._props()}get modelType(){let e=Z.get(this.modelClass);return e.name}};let ew=[];function typesLiteral(e){let t;switch(!function(e,t){if(!isPrimitive(e))throw failure(`${t} must be a primitive`)}(e,"literal"),e){case void 0:t="undefined";break;case null:t="null";break;default:t=JSON.stringify(e)}let n=new TypeChecker(C.Primitive,(n,r,o)=>n===e?null:new TypeCheckError(r,t,n,o),()=>t,t=>new LiteralTypeInfo(t,e),t=>t===e?n:null,identityFn,identityFn);return n}let LiteralTypeInfo=class LiteralTypeInfo extends TypeInfo{constructor(e,t){super(e),__publicField(this,"literal"),this.literal=t}};let eT=typesLiteral(void 0);ew.push(e=>void 0===e?eT:void 0);let eS=typesLiteral(null);ew.push(e=>null===e?eS:void 0);let eO=new TypeChecker(C.Primitive,(e,t,n)=>"boolean"==typeof e?null:new TypeCheckError(t,"boolean",e,n),()=>"boolean",e=>new BooleanTypeInfo(e),e=>"boolean"==typeof e?eO:null,identityFn,identityFn);ew.push(e=>e===Boolean?eO:void 0);let BooleanTypeInfo=class BooleanTypeInfo extends TypeInfo{};let e_=new TypeChecker(C.Primitive,(e,t,n)=>"number"==typeof e?null:new TypeCheckError(t,"number",e,n),()=>"number",e=>new NumberTypeInfo(e),e=>"number"==typeof e?e_:null,identityFn,identityFn);ew.push(e=>e===Number?e_:void 0);let NumberTypeInfo=class NumberTypeInfo extends TypeInfo{};let ek=new TypeChecker(C.Primitive,(e,t,n)=>"string"==typeof e?null:new TypeCheckError(t,"string",e,n),()=>"string",e=>new StringTypeInfo(e),e=>"string"==typeof e?ek:null,identityFn,identityFn);ew.push(e=>e===String?ek:void 0);let StringTypeInfo=class StringTypeInfo extends TypeInfo{};let eC=!1,eP=[];function findStandardType(e){for(let t of(!function(){if(!eC)eC=!0,eP.push(e=>isModelClass(e)?typesModel(e):void 0),ew.forEach(e=>{eP.push(e)})}(),eP)){let n=t(e);if(n)return n}}function resolveTypeChecker(e){let t=e;for(;;){if(t instanceof TypeChecker)return t;if(isLateTypeChecker(t))t=t();else{let t=findStandardType(e);if(t)return resolveTypeChecker(t);throw failure("type checker could not be resolved")}}}function resolveStandardTypeNoThrow(e){if(e instanceof TypeChecker||isLateTypeChecker(e))return e;{let t=findStandardType(e);return t||void 0}}function resolveStandardType(e){let t=resolveStandardTypeNoThrow(e);if(t)return t;throw failure("standard type could not be resolved")}let eI=new WeakMap,eM=new WeakMap;function getInternalSnapshot(e){return eI.get(e)}let ej=(0,N.action)("unsetInternalSnapshot",e=>{let t=getInternalSnapshot(e);t&&(eI.delete(e),t.atom.reportChanged())}),eA=(0,N.action)("setNewInternalSnapshot",(e,t,n,r=!1)=>{let o={untransformed:t,transformFn:n,transformed:n?n(t):t,atom:(0,N.createAtom)("snapshot")};eM.set(o.untransformed,r),void 0!==o.transformed&&eM.set(o.transformed,r),eI.set(e,o),o.atom.reportChanged()}),eD=(0,N.action)("updateInternalSnapshot",(e,t)=>{let n=getInternalSnapshot(e),r=n.untransformed,o=eM.get(r);o?r=Array.isArray(r)?r.slice():Object.assign({},r):function(e){let t=eb.get(e);t&&(t.forEach(t=>t.invalidateSnapshotProcessorCachedResult(e)),eb.delete(e))}(r),t(r),n.untransformed=r,n.transformed=n.transformFn?n.transformFn(r):r,eM.set(n.untransformed,!1),void 0!==n.transformed&&eM.set(n.transformed,!1),n.atom.reportChanged();let a=function(e,t){if(!t||!e)return;let n=getInternalSnapshot(t.parent);if(n)return{parentSnapshot:n,parentPath:t}}(n,fastGetParentPath(e));if(a){let{parentSnapshot:e,parentPath:t}=a;if(e){let e=t.path;eD(t.parent,t=>{t[e]=n.transformed})}}});function freezeInternalSnapshot(e){if(isPrimitive(e))return e;let t=eM.get(e);if(void 0===t||!0===t)return e;if(Array.isArray(e))for(let t=0;t<e.length;t++)freezeInternalSnapshot(e[t]);else{let t=Object.keys(e);for(let n=0;n<t.length;n++)freezeInternalSnapshot(e[t[n]])}return eM.set(e,!0),e}function getSnapshot(e,t){let n,r=identityFn;if(arguments.length>=2?(r=resolveTypeChecker(e).toSnapshotProcessor,n=t):n=e,isPrimitive(n))return r(n);assertTweakedObject(n,"nodeOrPrimitive");let o=getInternalSnapshot(n);if(!o)throw failure("getSnapshot is not supported for this kind of object");return freezeInternalSnapshot(o.transformed),!function(e){e.atom.reportObserved()}(o),r(o.transformed)}function typeCheck(e,t){let n=resolveTypeChecker(e);return n.unchecked?null:n.check(t,[],t)}(s=P||(P={})).DevModeOnly="devModeOnly",s.AlwaysOn="alwaysOn",s.AlwaysOff="alwaysOff";let eF=0,ex=((e=21)=>{let t="",n=e;for(;n--;)t+="useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict"[64*Math.random()|0];return t})(),eN={modelAutoTypeChecking:P.DevModeOnly,modelIdGenerator:function(){let e=eF.toString(36)+"-"+ex;return eF++,e},allowUndefinedArrayElements:!1,showDuplicateModelNameWarnings:!0};function setGlobalConfig(e){eN=Object.freeze({...eN,...e})}function isModelAutoTypeCheckingEnabled(){switch(eN.modelAutoTypeChecking){case P.DevModeOnly:case P.AlwaysOff:return!1;case P.AlwaysOn:return!0;default:throw failure(`invalid 'modelAutoTypeChecking' config value - ${eN.modelAutoTypeChecking}`)}}let e$=Symbol("modelInitializers");function applyModelInitializers(e,t){let n=e[e$];if(n){let e=n.length;for(let r=0;r<e;r++)n[r](t)}}function assertCanWrite(){if(!r)throw failure("data changes must be performed inside model actions")}let eR=[],eV=!1;(c=I||(I={})).OnInit="$$onInit",c.OnLazyInit="$$onLazyInit",c.OnAttachedToRootStore="$$onAttachedToRootStore",c.OnAttachedToRootStoreDisposer="$$onAttachedToRootStoreDisposer",Object.values(I);let ez=new WeakMap;function getObjectChildrenObject(e){let t=ez.get(e);return t||(t={shallow:new Set,shallowAtom:(0,N.createAtom)("shallowChildrenAtom"),deep:new Set,deepDirty:!0,deepAtom:(0,N.createAtom)("deepChildrenAtom"),extensionsData:initExtensionsData()},ez.set(e,t)),t}function getObjectChildren(e){let t=getObjectChildrenObject(e);return t.shallowAtom.reportObserved(),t.shallow}function addNodeToDeepLists(e,t){t.deep.add(e),eL.forEach((n,r)=>{n.addNode(e,t.extensionsData.get(r))})}let eE=(0,N.action)(e=>{let t=getObjectChildrenObject(e);if(!t.deepDirty)return t;let n={deep:new Set,extensionsData:initExtensionsData()},r=t.shallow.values(),o=r.next();for(;!o.done;){addNodeToDeepLists(o.value,n);let e=eE(o.value).deep,t=e.values(),a=t.next();for(;!a.done;)addNodeToDeepLists(a.value,n),a=t.next();o=r.next()}return Object.assign(t,n),t.deepDirty=!1,t.deepAtom.reportChanged(),t}),eG=(0,N.action)((e,t)=>{let n=getObjectChildrenObject(e);n.shallow.add(t),n.shallowAtom.reportChanged(),invalidateDeepChildren(e)}),eU=(0,N.action)((e,t)=>{let n=getObjectChildrenObject(e);n.shallow.delete(t),n.shallowAtom.reportChanged(),invalidateDeepChildren(e)});function invalidateDeepChildren(e){let t=getObjectChildrenObject(e);t.deepDirty||(t.deepDirty=!0,t.deepAtom.reportChanged());let n=fastGetParent(e);n&&invalidateDeepChildren(n)}let eL=new Map;function registerDeepObjectChildrenExtension(e){let t={};return eL.set(t,e),e=>e.extensionsData.get(t)}function initExtensionsData(){let e=new WeakMap;return eL.forEach((t,n)=>{e.set(n,t.initData())}),e}function walkTree(e,t,n){return(assertTweakedObject(e,"root"),n===M.ParentFirst)?function(e,t){let n=[e];for(;n.length>0;){let e=n.pop(),r=t(e);if(void 0!==r)return r;let o=getObjectChildren(e);n.length+=o.size;let a=n.length-1,l=o.values(),i=l.next();for(;!i.done;)n[a--]=i.value,i=l.next()}}(e,t):function walkTreeChildrenFirst(e,t){let n=getObjectChildren(e).values(),r=n.next();for(;!r.done;){let e=walkTreeChildrenFirst(r.value,t);if(void 0!==e)return e;r=n.next()}let o=t(e);if(void 0!==o)return o}(e,t)}(u=M||(M={})).ParentFirst="parentFirst",u.ChildrenFirst="childrenFirst";let eB=new WeakMap,eW=new WeakSet,eJ=(0,N.action)("attachToRootStore",(e,t)=>{let n=[];walkTree(t,e=>{!eW.has(e)&&(eW.add(e),e instanceof BaseModel&&e.onAttachedToRootStore&&(wrapModelMethodInActionIfNeeded(e,"onAttachedToRootStore",I.OnAttachedToRootStore),n.push(e)))},M.ParentFirst);let r=n.length;for(let t=0;t<r;t++){let r=n[t],o=r.onAttachedToRootStore(e);o&&eB.set(r,o)}}),eQ=(0,N.action)("detachFromRootStore",e=>{let t=[];walkTree(e,e=>{if(!eW.delete(e))return;let n=eB.get(e);if(n){let r=wrapInAction({nameOrNameFn:I.OnAttachedToRootStoreDisposer,fn:n,actionType:_.Sync}).bind(e);eB.delete(e),t.push(r)}},M.ChildrenFirst);let n=t.length;for(let e=0;e<n;e++)t[e]()}),eq=new WeakMap,getOrCreateRootStoreEntry=e=>getOrCreate(eq,e,()=>({atom:(0,N.createAtom)("rootStore"),is:!1})),eH=(0,N.action)("registerRootStore",e=>{assertTweakedObject(e,"node");let t=getOrCreateRootStoreEntry(e);if(t.is)throw failure("object already registered as root store");if(assertTweakedObject(e,"value"),fastGetParent(e))throw failure("a root store must not have a parent");return t.is=!0,eJ(e,e),t.atom.reportChanged(),e});function isRootStore(e){return assertTweakedObject(e,"node"),fastIsRootStore(e)}function fastIsRootStore(e){let t=getOrCreateRootStoreEntry(e);return t.atom.reportObserved(),t.is}function getRootStore(e){return assertTweakedObject(e,"node"),function(e){let t=fastGetRoot(e);return fastIsRootStore(t)?t:void 0}(e)}(0,N.action)("unregisterRootStore",e=>{if(!isRootStore(e))throw failure("not a root store");let t=getOrCreateRootStoreEntry(e);t.is=!1,eQ(e),t.atom.reportChanged()});let eK=[];let InternalPatchRecorder=class InternalPatchRecorder{constructor(){__publicField(this,"patches",eK),__publicField(this,"invPatches",eK)}reset(){this.patches=eK,this.invPatches=eK}record(e,t){this.patches=e,this.invPatches=t}emit(e){(function emitPatch(e,t,n,r){if(t.length<=0&&n.length<=0)return;if(r)for(let r=0;r<eY.length;r++){let o=eY[r];o(e,t,n)}let o=eX.get(e);if(o)for(let e=0;e<o.length;e++){let r=o[e];r(t,n)}let a=fastGetParentPath(e);if(a){let e=a.path,r=t.map(t=>addPathToPatch(t,e)),o=n.map(t=>addPathToPatch(t,e));emitPatch(a.parent,r,o,!1)}})(e,this.patches,this.invPatches,!0),this.reset()}};let eX=new WeakMap,eY=[];function addPathToPatch(e,t){return{...e,path:[t,...e.path]}}function setIfDifferent(e,t,n){let r=e[t];r===n&&(void 0!==n||t in e)||(0,N.set)(e,t,n)}function getDataModelMetadata(e){if(isDataModel(e))return e.constructor[ea];if(isDataModelClass(e))return e[ea];throw failure("modelClassOrInstance must be a model class or instance")}let eZ=new WeakMap;let DataModelDataTypeInfo=class DataModelDataTypeInfo extends TypeInfo{constructor(e,t){super(e),__publicField(this,"modelClass"),__publicField(this,"_props",lazy(()=>{let e=this.modelClass[ec],t={};return Object.keys(e).forEach(n=>{let r,o;let a=e[n],l=a._typeChecker;l&&(r=getTypeInfo(l));let i=!1;a._defaultFn!==eu?(o=a._defaultFn,i=!0):a._defaultValue!==eu&&(o=a._defaultValue,i=!0),t[n]={type:l,typeInfo:r,hasDefault:i,default:o}}),t})),this.modelClass=t}get props(){return this._props()}get modelType(){let e=Z.get(this.modelClass);return e.name}};let e0=(0,N.action)("newModel",(e,t,n)=>{let{modelClass:r}=n,o=Z.get(r);if(!o)throw failure(`no model info for class ${r.name} could be found - did you forget to add the @model decorator?`);if(e.$=t,applyModelInitializers(r,e),isModelAutoTypeCheckingEnabled()&&getDataModelMetadata(r).dataType){let t=e.typeCheck();t&&t.throw()}return e}),e1=new WeakMap;let BaseDataModel=class BaseDataModel{constructor(e){let t;if(__publicField(this,b),__publicField(this,"$"),!isObject(e))throw failure("data models can only work over data objects");let{modelClass:n}=arguments[1];if(isTreeNode(e))t=e;else{let r=Z.get(n);if(!r)throw failure(`no model info for class ${n.name} could be found - did you forget to add the @model decorator?`);let o=n[ec],a=Object.assign({},e),l=Object.keys(o);for(let e=0;e<l.length;e++){let t=l[e],n=o[t],r=a[t],i=!1;n._transform&&(i=!0,r=n._transform.untransform(r,this,t)),null==r&&(n._defaultFn!==eu?(i=!0,r=n._defaultFn()):n._defaultValue!==eu&&(i=!0,r=n._defaultValue)),i&&(a[t]=r)}t=toTreeNode(a)}let r=getOrCreate(e1,n,()=>new WeakMap),o=r.get(t);if(o)return o;r.set(t,this),Object.setPrototypeOf(this,n.prototype),delete this[q],e0(this,t,{modelClass:n})}typeCheck(){let e=function typesDataModelData(e){if(!isDataModelClass(e)&&"function"==typeof e)return lateTypeChecker(()=>typesDataModelData(e()),t=>new DataModelDataTypeInfo(t,e()));{let t=eZ.get(e);if(t)return t;let typeInfoGen=t=>new DataModelDataTypeInfo(t,e),n=lateTypeChecker(()=>{let t=Z.get(e),n=`DataModelData(${t.name})`,r=getDataModelMetadata(e).dataType;if(!r)throw failure(`type checking cannot be performed over data model data of type '${t.name}' since that model type has no data type declared, consider adding a data type or using types.unchecked() instead`);let o=resolveTypeChecker(r),a=new TypeChecker(C.Object,(e,t,n)=>o.check(e,t,n),()=>n,typeInfoGen,e=>o.snapshotType(e)?a:null,e=>o.fromSnapshotProcessor(e),e=>o.toSnapshotProcessor(e));return a},typeInfoGen);return eZ.set(e,n),n}}(this.constructor);return typeCheck(e,this.$)}toString(e){let t={withData:!0,...e},n=Z.get(this.constructor),r=`${this.constructor.name}#${n.name}`;return t.withData?`[${r} ${JSON.stringify(getSnapshot(this))}]`:`[${r}]`}};b=q;let e6=new Set(["onLazyInit","$","typeCheck"]);function isDataModel(e){return e instanceof BaseDataModel}function isDataModelClass(e){return"function"==typeof e&&(e===BaseDataModel||e.prototype instanceof BaseDataModel)}(d=j||(j={})).DevModeOnly="devModeOnly",d.On="on",d.Off="off";let e3="$frozen";let Frozen=class Frozen{constructor(e,t=j.DevModeOnly){__publicField(this,"data");let n=t===j.On;n&&function checkDataIsSerializableAndFreeze(e){if(!isPrimitive(e)){if(Array.isArray(e)){let t=e.length;for(let n=0;n<t;n++){let t=e[n];if(void 0===t&&!eN.allowUndefinedArrayElements)throw failure("undefined is not supported inside arrays since it is not serializable in JSON, consider using null instead");checkDataIsSerializableAndFreeze(t)}Object.freeze(e);return}if(isPlainObject(e)){let t=Object.keys(e),n=t.length;for(let r=0;r<n;r++){let n=t[r],o=e[n];checkDataIsSerializableAndFreeze(n),checkDataIsSerializableAndFreeze(o)}Object.freeze(e);return}throw failure(`frozen data must be plainly serializable to JSON, but ${e} is not`)}}(e),this.data=e,n&&Object.freeze(this.data),tl(this,void 0)}};function frozen(e,t=j.DevModeOnly){return new Frozen(e,t)}function isFrozenSnapshot(e){return isPlainObject(e)&&e3 in e}function findParent(e,t,n=0){let r=function(e,t,n=0){let r;assertTweakedObject(e,"child");let o=[],a=e,l=0;for(;r=fastGetParentPath(a);){if(o.unshift(r.path),t(a=r.parent))return{parent:a,path:o};if(l++,n>0&&l===n)break}}(e,t,n);return r?r.parent:void 0}(p=A||(A={}))[p.Model=0]="Model",p[p.Array=1]="Array",p[p.PlainObject=2]="PlainObject",p[p.Frozen=3]="Frozen";let e2=!0;function withoutTypeChecking(e){let t=e2;e2=!1;try{e()}finally{e2=t}}(h=D||(D={}))[h.Array=0]="Array",h[h.Frozen=1]="Frozen",h[h.Model=2]="Model",h[h.PlainObject=3]="PlainObject";let e9=(f=function equal(e,t){if(e===t)return!0;if(e&&t&&"object"==typeof e&&"object"==typeof t){if(e.constructor!==t.constructor)return!1;if(Array.isArray(e)){if((n=e.length)!=t.length)return!1;for(r=n;0!=r--;)if(!equal(e[r],t[r]))return!1;return!0}if(e instanceof Map&&t instanceof Map){if(e.size!==t.size)return!1;for(r of e.entries())if(!t.has(r[0]))return!1;for(r of e.entries())if(!equal(r[1],t.get(r[0])))return!1;return!0}if(e instanceof Set&&t instanceof Set){if(e.size!==t.size)return!1;for(r of e.entries())if(!t.has(r[0]))return!1;return!0}if(ArrayBuffer.isView(e)&&ArrayBuffer.isView(t)){if((n=e.length)!=t.length)return!1;for(r=n;0!=r--;)if(e[r]!==t[r])return!1;return!0}if(e.constructor===RegExp)return e.source===t.source&&e.flags===t.flags;if(e.valueOf!==Object.prototype.valueOf)return e.valueOf()===t.valueOf();if(e.toString!==Object.prototype.toString)return e.toString()===t.toString();if((n=(o=Object.keys(e)).length)!==Object.keys(t).length)return!1;for(r=n;0!=r--;)if(!Object.prototype.hasOwnProperty.call(t,o[r]))return!1;for(r=n;0!=r--;){var n,r,o,a=o[r];if(!equal(e[a],t[a]))return!1}return!0}return e!=e&&t!=t}).__esModule&&Object.prototype.hasOwnProperty.call(f,"default")?f.default:f;let ModelPool=class ModelPool{constructor(e){var t;__publicField(this,"pool"),e=null!=(t=en.get(e))?t:e,this.pool=e4(function(e){let t=getObjectChildrenObject(e);return t.deepDirty&&eE(e),t.deepAtom.reportObserved(),t}(e))}findModelByTypeAndId(e,t){return t?this.pool.get(e+" "+t):void 0}findModelForSnapshot(e){if(!isModelSnapshot(e))return;let t=e[z],n=Y[t],r=getModelIdPropertyName(n.class);return r?this.findModelByTypeAndId(e[z],e[r]):void 0}};let e4=registerDeepObjectChildrenExtension({initData:()=>new Map,addNode(e,t){if(isModel(e)){let n=e[E];n&&t.set(e[z]+" "+n,e)}}});function applySnapshot(e,t){assertTweakedObject(e,"node"),assertIsObject(t,"snapshot"),e5().call(e,t)}function internalApplySnapshot(e){let t=this,reconcile=()=>{let n=new ModelPool(t);reconcileSnapshot(t,e,n,void 0)};if(isArray(e)){if(!isArray(t))throw failure("if the snapshot is an array the target must be an array too");return reconcile()}if(isFrozenSnapshot(e))throw failure("applySnapshot cannot be used over frozen objects");if(isPlainObject(e)&&void 0===e[z]&&isModel(t)){let n=Z.get(t.constructor);e={...e,[z]:n.name}}if(isModelSnapshot(e)){let n=e[z],r=Y[n];if(!r)throw failure(`model with name "${n}" not found in the registry`);if(!isModel(t))throw failure("the target for a model snapshot must be a model instance");if(t[z]!==n)throw failure(`snapshot model type '${n}' does not match target model type '${t[z]}'`);let o=getModelIdPropertyName(r.class);if(o){let n=e[o];if(t[E]!==n)throw failure(`snapshot model id '${n}' does not match target model id '${t[E]}'`)}return reconcile()}if(isPlainObject(e)){if(!isPlainObject(t)&&!(0,N.isObservableObject)(t))throw failure("if the snapshot is an object the target must be an object too");return reconcile()}if(isMap(e))throw failure("a snapshot must not contain maps");if(isSet(e))throw failure("a snapshot must not contain sets");throw failure(`unsupported snapshot - ${e}`)}let e5=lazy(()=>wrapInAction({nameOrNameFn:O.ApplySnapshot,fn:internalApplySnapshot,actionType:_.Sync}));function onSnapshot(e,t){let n="function"==typeof e?e:()=>e,r=n();assertTweakedObject(r,"node");let o=getSnapshot(r);return(0,N.reaction)(()=>getSnapshot(n()),e=>{let n=o;o=e,t(e,n)})}function deepEquals(e,t){return e===t||(isTreeNode(e)?e=getSnapshot(e):(0,N.isObservable)(e)&&(e=(0,N.toJS)(e,e8)),isTreeNode(t)?t=getSnapshot(t):(0,N.isObservable)(t)&&(t=(0,N.toJS)(t,e8)),e9(e,t))}let e8=getMobxVersion()>=6?void 0:{exportMapsAsObjects:!1,recurseEverything:!1},e7=!1,te=[];function registerReconciler(e,t){te.push({priority:e,reconciler:t}),te.sort((e,t)=>e.priority-t.priority)}function reconcileSnapshot(e,t,n,r){if(isPrimitive(t))return t;if(getSnapshot(e)===t)return e;e7||(e7=!0,registerReconciler(D.Array,(e,t,n)=>{if(isArray(t))return function(e,t,n){if(!isArray(e))return fromSnapshot(t);let r=getSnapshot(e);return withoutTypeChecking(()=>{e.length>t.length&&e.splice(t.length,e.length-t.length);for(let r=0;r<e.length;r++){let o=e[r],a=reconcileSnapshot(o,t[r],n,e);detachIfNeeded(a,o,n),setIfDifferent(e,r,a)}for(let r=e.length;r<t.length;r++)e.push(reconcileSnapshot(void 0,t[r],n,e))}),runTypeCheckingAfterChange(e,void 0,r),e}(e,t,n)}),registerReconciler(D.Frozen,(e,t)=>{if(isFrozenSnapshot(t))return e instanceof Frozen&&e.data===t.data?e:frozen(t.data)}),registerReconciler(D.Model,(e,t,n,r)=>{if(isModelSnapshot(t))return function(e,t,n,r){let o=t[z],a=Y[o];if(!a)throw failure(`model with name "${o}" not found in the registry`);let l=n.findModelForSnapshot(t);if(l&&(e=l),!isModel(e)||e[z]!==o)return fromSnapshot(t);let i=a.class,s=i[ec],c=getModelIdPropertyName(i);if(c){let n=t[c];if(e[E]!==n)return fromSnapshot(t)}else if(isArray(r)&&!deepEquals(e,t))return fromSnapshot(t);let u=getSnapshot(e);return withoutTypeChecking(()=>{let r=e.constructor,o=r.fromSnapshotProcessor?r.fromSnapshotProcessor(t):t,a=e.$,l=Object.keys(a),i=l.length;for(let e=0;e<i;e++){let t=l[e];if(!(t in o)){let e=s[t],n=e?getModelPropDefaultValue(e):eu;n===eu?(0,N.remove)(a,t):setIfDifferent(a,t,n)}}let c=Object.keys(o),u=c.length;for(let t=0;t<u;t++){let r=c[t];if(r!==z){let t=o[r],l=a[r],i=reconcileSnapshot(l,t,n,e);if(null==i){let e=s[r],t=e?getModelPropDefaultValue(e):eu;t!==eu&&(i=t)}detachIfNeeded(i,l,n),setIfDifferent(a,r,i)}}}),runTypeCheckingAfterChange(e,void 0,u),e}(e,t,n,r)}),registerReconciler(D.PlainObject,(e,t,n)=>{if(isPlainObject(t))return function(e,t,n){if(!isPlainObject(e)&&!(0,N.isObservableObject)(e))return fromSnapshot(t);let r=getSnapshot(e);return withoutTypeChecking(()=>{let r=Object.keys(e),o=r.length;for(let n=0;n<o;n++){let o=r[n];o in t||(0,N.remove)(e,o)}let a=Object.keys(t),l=a.length;for(let r=0;r<l;r++){let o=a[r],l=t[o],i=e[o],s=reconcileSnapshot(i,l,n,e);detachIfNeeded(s,i,n),setIfDifferent(e,o,s)}}),runTypeCheckingAfterChange(e,void 0,r),e}(e,t,n)}));let o=te.length;for(let a=0;a<o;a++){let{reconciler:o}=te[a],l=o(e,t,n,r);if(void 0!==l)return l}if(isMap(t))throw failure("a snapshot must not contain maps");if(isSet(t))throw failure("a snapshot must not contain sets");throw failure(`unsupported snapshot - ${t}`)}function detachIfNeeded(e,t,n){if(e!==t&&isModel(e)&&n.findModelByTypeAndId(e[z],e[E])){let t=fastGetParentPathIncludingDataObjects(e);t&&(0,N.set)(t.parent,t.path,null)}}function applyPatches(e,t,n=!1){assertTweakedObject(e,"node"),t.length<=0||tt().call(e,t,n)}function internalApplyPatches(e,t=!1){let n=new ModelPool(this);if(t){let t=e.length;for(;t--;){let r=e[t];if(isArray(r)){let e=r.length;for(;e--;)applySinglePatch(this,r[e],n)}else applySinglePatch(this,r,n)}}else{let t=e.length;for(let r=0;r<t;r++){let t=e[r];if(isArray(t)){let e=t.length;for(let r=0;r<e;r++)applySinglePatch(this,t[r],n)}else applySinglePatch(this,t,n)}}}let tt=lazy(()=>wrapInAction({nameOrNameFn:O.ApplyPatches,fn:internalApplyPatches,actionType:_.Sync}));function applySinglePatch(e,t,n){let{target:r,prop:o}=function(e,t){let n=modelToDataNode(e);if(0===t.length)return{target:n};for(let e=0;e<=t.length-2;e++)n=modelToDataNode(n[t[e]]);return{target:n,prop:t[t.length-1]}}(e,t.path);if(isArray(r))switch(t.op){case"add":{let e=+o,a=reconcileSnapshot(void 0,t.value,n,r);r.splice(e,0,a);break}case"remove":{let e=+o;r.splice(e,1);break}case"replace":if("length"===o)r.length=t.value;else{let e=+o,a=reconcileSnapshot(r[e],t.value,n,r);setIfDifferent(r,e,a)}break;default:throw failure(`unsupported patch operation: ${t.op}`)}else switch(t.op){case"add":{let e=reconcileSnapshot(void 0,t.value,n,r);setIfDifferent(r,o,e);break}case"remove":(0,N.remove)(r,o);break;case"replace":{let e=reconcileSnapshot(r[o],t.value,n,r);setIfDifferent(r,o,e);break}default:throw failure(`unsupported patch operation: ${t.op}`)}}function runTypeCheckingAfterChange(e,t,n){if(e2&&(!function(e){let t=e;for(;t;){let e=em.get(t);e&&(em.delete(t),e.forEach(e=>e.invalidateCachedResult(t))),t=function(e){var t;return null==(t=fastGetParentPathIncludingDataObjects(e))?void 0:t.parent}(t)}}(e),isModelAutoTypeCheckingEnabled())){let r=function(e){let t=dataToModelNode(e);return e!==t&&isModel(e=t)&&getModelMetadata(e).dataType?e:findParent(e,e=>isModel(e)&&!!getModelMetadata(e).dataType)}(e);if(r){let o=r.typeCheck();o&&(!function(e){let t=eo;eo=!0;try{(0,N.runInAction)(()=>{e()})}finally{eo=t}}(()=>{t?internalApplyPatches.call(e,t.invPatches,!0):n&&internalApplySnapshot.call(e,n)}),o.throw())}}}function tweakPlainObject(e,t,n,r,o){let a,l,i;let s=(0,N.isObservableObject)(e)?e:N.observable.object({},void 0,tn);er.set(s,()=>{a(),l()}),th({value:s,parentPath:t,indexChangeAllowed:!1,isDataObject:o,cloneIfApplicable:!1});let c={},u=Object.keys(e),d=u.length;for(let t=0;t<d;t++){let n=u[t],o=e[n];if(isPrimitive(o))r||setIfDifferent(s,n,o),c[n]=o;else{let e;let t={parent:s,path:n};r?th({value:e=o,parentPath:t,indexChangeAllowed:!1,isDataObject:!1,cloneIfApplicable:!1}):setIfDifferent(s,n,e=tl(o,t));let a=getInternalSnapshot(e);c[n]=a.transformed}}if(n){c[z]=n;let e=Y[n];if(!e)throw failure(`model with name "${n}" not found in the registry`);let t=e.class.toSnapshotProcessor;t&&(i=e=>t(e,dataToModelNode(s)))}return eA(o?dataToModelNode(s):s,c,i),a=(0,N.intercept)(s,interceptObjectMutation),l=(0,N.observe)(s,objectDidChange),s}let tn={deep:!1};function mutateSet$1(e,t,n){n[e]=t}function mutateDelete(e,t){delete t[e]}let tr=new InternalPatchRecorder;function objectDidChange(e){let t;let n=e.object,r=dataToModelNode(n),o=getInternalSnapshot(r).untransformed;switch(tr.reset(),e.type){case"add":case"update":t=function(e,t){let n;let r=e.name,o=e.newValue,a=t[r];if(isPrimitive(o))n=o;else{let e=getInternalSnapshot(o);n=e.transformed}let l=mutateSet$1.bind(void 0,r,n),i=[r];return"add"===e.type?tr.record([{op:"add",path:i,value:freezeInternalSnapshot(n)}],[{op:"remove",path:i}]):tr.record([{op:"replace",path:i,value:freezeInternalSnapshot(n)}],[{op:"replace",path:i,value:freezeInternalSnapshot(a)}]),l}(e,o);break;case"remove":t=function(e,t){let n=e.name,r=t[n],o=mutateDelete.bind(void 0,n),a=[n];return tr.record([{op:"remove",path:a}],[{op:"add",path:a,value:freezeInternalSnapshot(r)}]),o}(e,o)}runTypeCheckingAfterChange(n,tr),!eo&&t&&(eD(r,t),tr.emit(r))}function interceptObjectMutation(e){if(assertCanWrite(),"symbol"==typeof e.name)throw failure("symbol properties are not supported");switch(e.type){case"add":e.newValue=tl(e.newValue,{parent:e.object,path:""+e.name});break;case"remove":{let t=e.object[e.name];tl(t,void 0);break}case"update":{let t=e.object[e.name],n=e.newValue;n!==t&&(tl(t,void 0),e.newValue=tl(e.newValue,{parent:e.object,path:""+e.name}))}}return e}let to=!1;function toTreeNode(e,t){let n,r,o;if(1==arguments.length?(o=!1,n=e):(r=e,o=!0,n=t),!isObject(n))throw failure("only objects can be turned into tree nodes");if(o&&isModelAutoTypeCheckingEnabled()){let e=typeCheck(r,n);e&&e.throw()}return isTweakedObject(n,!0)?n:tl(n,void 0)}let ta=[];function registerTweaker(e,t){ta.push({priority:e,tweaker:t}),ta.sort((e,t)=>e.priority-t.priority)}let tl=(0,N.action)("tweak",function(e,t){if(isPrimitive(e))return e;if(isTweakedObject(e,!0))return e=th({value:e,parentPath:t,indexChangeAllowed:!1,isDataObject:!1,cloneIfApplicable:!0});if(isDataModel(e))throw failure("data models are not directly supported. you may insert the data in the tree instead ('$' property).");to||(to=!0,registerTweaker(A.Array,(e,t)=>{if(isArray(e))return tweakArray(e,t,!1)}),registerTweaker(A.Frozen,(e,t)=>{if(e instanceof Frozen)return er.set(e,void 0),th({value:e,parentPath:t,indexChangeAllowed:!1,isDataObject:!1,cloneIfApplicable:!1}),eA(e,{[e3]:!0,data:e.data},void 0,!0),e}),registerTweaker(A.Model,(e,t)=>{if(isModel(e))return tweakModel(e,t)}),registerTweaker(A.PlainObject,(e,t)=>{if((0,N.isObservableObject)(e)||isPlainObject(e))return tweakPlainObject(e,t,void 0,!1,!1)}));let n=ta.length;for(let r=0;r<n;r++){let{tweaker:n}=ta[r],o=n(e,t);if(void 0!==o)return o}if(isMap(e))throw failure("maps are not directly supported. consider using 'ObjectMap' / 'asMap' instead.");if(isSet(e))throw failure("sets are not directly supported. consider using 'ArraySet' / 'asSet' instead.");throw failure(`tweak can only work over models, observable objects/arrays, or primitives, but got ${e} instead`)});function tweakArray(e,t,n){let r,o;let a=e.length,l=(0,N.isObservableArray)(e)?e:N.observable.array(void 0,ts);l!==e&&(l.length=e.length),er.set(l,()=>{r(),o()}),th({value:l,parentPath:t,indexChangeAllowed:!1,isDataObject:!1,cloneIfApplicable:!1});let i=[];i.length=a;for(let t=0;t<a;t++){let r=e[t];if(isPrimitive(r))n||setIfDifferent(l,t,r),i[t]=r;else{let e;let o={parent:l,path:t};n?th({value:e=r,parentPath:o,indexChangeAllowed:!1,isDataObject:!1,cloneIfApplicable:!1}):setIfDifferent(l,t,e=tl(r,o));let a=getInternalSnapshot(e);i[t]=a.transformed}}return eA(l,i,void 0),r=(0,N.intercept)(l,interceptArrayMutation.bind(void 0,l)),o=(0,N.observe)(l,arrayDidChange),l}function mutateSet(e,t,n){n[e]=t}function mutateSplice(e,t,n,r){r.splice(e,t,...n)}let ti=new InternalPatchRecorder;function arrayDidChange(e){let t;let n=e.object,r=getInternalSnapshot(n).untransformed;switch(ti.reset(),e.type){case"splice":t=function(e,t){let n=e.index,r=e.addedCount,o=e.removedCount,a=[];a.length=r;for(let t=0;t<r;t++){let n=e.added[t];isPrimitive(n)?a[t]=n:a[t]=getInternalSnapshot(n).transformed}let l=t.length,i=mutateSplice.bind(void 0,n,o,a),s=[],c=[];if(r===o){let e=[],l=[],i=0;for(let u=0;u<r;u++){let r=n+u,d=getValueAfterSplice(t,r,n,o,a),p=t[r];if(d!==p){let t=[r-i];s.push({op:"remove",path:t}),c.push({op:"remove",path:t}),i++;let n=[r];e.push({op:"add",path:n,value:freezeInternalSnapshot(d)}),l.push({op:"add",path:n,value:freezeInternalSnapshot(p)})}}s.push(...e),c.push(...l),c.reverse()}else{let e=l-o;if(o>0){let r=n>=e;r&&s.push({op:"replace",path:["length"],value:e});for(let e=o-1;e>=0;e--){let o=n+e,a=[o];r||s.push({op:"remove",path:a}),c.push({op:"add",path:a,value:freezeInternalSnapshot(t[o])})}}if(r>0){let l=n>=e;l&&c.push({op:"replace",path:["length"],value:e});for(let e=0;e<r;e++){let r=n+e,i=[r];s.push({op:"add",path:i,value:freezeInternalSnapshot(getValueAfterSplice(t,r,n,o,a))}),l||c.push({op:"remove",path:i})}}}return ti.record(s,c),i}(e,r);break;case"update":t=function(e,t){let n;let r=e.index,o=e.newValue,a=t[r];if(isPrimitive(o))n=o;else{let e=getInternalSnapshot(o);n=e.transformed}let l=mutateSet.bind(void 0,r,n),i=[r];return ti.record([{op:"replace",path:i,value:freezeInternalSnapshot(n)}],[{op:"replace",path:i,value:freezeInternalSnapshot(a)}]),l}(e,r)}runTypeCheckingAfterChange(n,ti),!eo&&t&&(eD(n,t),ti.emit(n))}function interceptArrayMutation(e,t){switch(assertCanWrite(),t.type){case"splice":!function(e){for(let t=0;t<e.removedCount;t++){let n=e.object[e.index+t];tl(n,void 0)}for(let t=0;t<e.added.length;t++)e.added[t]=tl(e.added[t],{parent:e.object,path:e.index+t});let t=e.index+e.removedCount,n=e.index+e.added.length;if(t!==n)for(let r=t,o=n;r<e.object.length;r++,o++)th({value:e.object[r],parentPath:{parent:e.object,path:o},indexChangeAllowed:!0,isDataObject:!1,cloneIfApplicable:!1})}(t);break;case"update":!function(e,t){let n=t[e.index];tl(n,void 0),e.newValue=tl(e.newValue,{parent:t,path:e.index})}(t,e)}return t}let ts={deep:!1};function getValueAfterSplice(e,t,n,r,o){let a=t-n;return a<0?e[t]:a<o.length?o[a]:e[t-o.length+r]}let tc=!1,tu=[];function registerSnapshotter(e,t){tu.push({priority:e,snapshotter:t}),tu.sort((e,t)=>e.priority-t.priority)}function fromSnapshot(e,t,n){let r,o;if(isLateTypeChecker(e)||e instanceof TypeChecker||isModelClass(e)){let a=resolveTypeChecker(e);r=a.fromSnapshotProcessor?a.fromSnapshotProcessor(t):t,o=n}else r=e,o=t;return td(r,o)}let td=(0,N.action)("fromSnapshot",(e,t)=>{let n={generateNewIds:!1,overrideRootModelId:void 0,...t},r={options:n};return r.snapshotToInitialData=snapshotToInitialData.bind(void 0,r),internalFromSnapshot(e,r)});function internalFromSnapshot(e,t){if(isPrimitive(e))return e;tc||(tc=!0,registerSnapshotter(D.Array,(e,t)=>{if(isArray(e))return function(e,t){let n=N.observable.array([],tp),r=e.length;for(let o=0;o<r;o++)n.push(internalFromSnapshot(e[o],t));return tweakArray(n,void 0,!0)}(e,t)}),registerSnapshotter(D.Frozen,e=>{if(isFrozenSnapshot(e))return frozen(e.data)}),registerSnapshotter(D.Model,(e,t)=>{if(isModelSnapshot(e))return function(e,t){let n=e[z];if(!n)throw failure(`a model snapshot must contain a type key (${z}), but none was found`);let r=Y[n];if(!r)throw failure(`model with name "${n}" not found in the registry`);let o=getModelIdPropertyName(r.class);if(o&&void 0===e[o])throw failure(`a model snapshot of type '${n}' must contain an id key (${o}), but none was found`);return new r.class(void 0,{snapshotInitialData:{unprocessedSnapshot:e,snapshotToInitialData:t.snapshotToInitialData},generateNewIds:t.options.generateNewIds})}(e,t)}),registerSnapshotter(D.PlainObject,(e,t)=>{if(isPlainObject(e))return function(e,t){let n=N.observable.object({},void 0,tp),r=Object.keys(e),o=r.length;for(let a=0;a<o;a++){let o=r[a],l=e[o];(0,N.set)(n,o,internalFromSnapshot(l,t))}return tweakPlainObject(n,void 0,void 0,!0,!1)}(e,t)}));let n=tu.length;for(let r=0;r<n;r++){let{snapshotter:n}=tu[r],o=n(e,t);if(void 0!==o)return o}if(isMap(e))throw failure("a snapshot must not contain maps");if(isSet(e))throw failure("a snapshot must not contain sets");throw failure(`unsupported snapshot - ${e}`)}function snapshotToInitialData(e,t){let n=N.observable.object({},void 0,tp),r=Object.keys(t),o=r.length;for(let a=0;a<o;a++){let o=r[a];if(o!==z){let r=t[o];(0,N.set)(n,o,internalFromSnapshot(r,e))}}return n}let tp={deep:!1},th=(0,N.action)("setParent",({value:e,parentPath:t,indexChangeAllowed:n,isDataObject:o,cloneIfApplicable:a})=>{let l;if(isPrimitive(e))return e;let i=fastGetParentPath(e);if(function(e,t,n=!0){if(!e&&!t)return!0;if(!e||!t)return!1;let r=e.parent===t.parent;return!!r&&(!n||e.path===t.path)}(i,t))return e;if(fastIsRootStore(e))throw failure("root stores cannot be attached to any parents");if(o)return en.set(e,t.parent),e;if(t){let e=dataToModelNode(t.parent);t.parent!==e&&(t={parent:e,path:t.path})}if(a&&(null==t?void 0:t.parent)&&(null==i?void 0:i.parent)&&isModel(e)&&getModelMetadata(e).valueType&&(i=fastGetParentPath(e=function(e,t){assertTweakedObject(e,"node");let n={generateNewIds:!0,...t},r=getSnapshot(e);return fromSnapshot(r,n)}(e,{generateNewIds:!0}))),i&&t){if(i.parent===t.parent&&n)return ee.set(e,t),reportParentPathChanged(e),e;throw failure("an object cannot be assigned a new parent when it already has one")}t||(l=function(e){if(isPrimitive(e))return;let t=er.get(e);if(!t)return;let n=Array.from(getObjectChildren(e).values());for(let e=0;e<n.length;e++)th({value:n[e],parentPath:void 0,indexChangeAllowed:!1,isDataObject:!1,cloneIfApplicable:!1});return()=>{t(),er.delete(e),ej(e)}}(e));let attachToNewParent=()=>{(null==i?void 0:i.parent)&&eU(i.parent,e),ee.set(e,t),(null==t?void 0:t.parent)&&eG(t.parent,e),reportParentPathChanged(e)};if(e instanceof BaseModel){let t=fastGetRoot(e),n=fastIsRootStore(t)?t:void 0;attachToNewParent();let o=fastGetRoot(e),a=fastIsRootStore(o)?o:void 0;if(n!==a&&(n||a)){var s;s=()=>{n&&eQ(e),a&&eJ(a,e)},r?eR.push(s):s()}}else attachToNewParent();return null==l||l(),e});function tweakModel(e,t){return er.set(e,void 0),th({value:e,parentPath:t,indexChangeAllowed:!1,isDataObject:!1,cloneIfApplicable:!0}),e}let tf=(0,N.action)("newModel",(e,t,n)=>{let r;let o=t?"new":"fromSnapshot",{modelClass:a,snapshotInitialData:l,generateNewIds:i}=n,s=Z.get(a);if(!s)throw failure(`no model info for class ${a.name} could be found - did you forget to add the @model decorator?`);let c=getModelIdPropertyName(a),u=a[ec],d=c?u[c]:void 0;if(l){let e=l.unprocessedSnapshot;d&&c&&(r=i?d._defaultFn():e[c]),a.fromSnapshotProcessor&&(e=a.fromSnapshotProcessor(e)),t=l.snapshotToInitialData(e)}else d&&c&&(r=t[c]?t[c]:d._defaultFn());e[z]=s.name;let p=Object.keys(u);for(let n=0;n<p.length;n++){let r=p[n];if(r===c)continue;let a=u[r],l=t[r],i=!1;if("new"===o&&a._transform&&(i=!0,l=a._transform.untransform(l,e,r)),null==l){let e=getModelPropDefaultValue(a);e!==eu?(i=!0,l=e):r in t||(i=!0)}i&&(0,N.set)(t,r,l)}if(c&&(0,N.set)(t,c,r),tweakModel(e,void 0),e.$=tweakPlainObject(t,{parent:e,path:"$"},e[z],!1,!0),applyModelInitializers(a,e),isModelAutoTypeCheckingEnabled()&&getModelMetadata(a).dataType){let t=e.typeCheck();t&&t.throw()}return e}),ty=Symbol("modelIdPropertyName");let BaseModel=class BaseModel{constructor(e){__publicField(this,g),__publicField(this,v),__publicField(this,w),__publicField(this,T),__publicField(this,S),__publicField(this,"$");let{snapshotInitialData:t,modelClass:n,generateNewIds:r}=arguments[1];Object.setPrototypeOf(this,n.prototype),delete this[q],delete this[H],delete this[K],delete this[ty],t?tf(this,void 0,{modelClass:n,snapshotInitialData:t,generateNewIds:r}):(assertIsObject(e,"initialData"),tf(this,N.observable.object(e,void 0,{deep:!1}),{modelClass:n,generateNewIds:!0}))}get[(g=q,v=H,w=K,T=ty,S=z,E)](){let e=getModelIdPropertyName(this.constructor);return e?this.$[e]:void 0}set[E](e){let t=getModelIdPropertyName(this.constructor);if(!t)throw failure("$modelId cannot be set when there is no idProp set in the model");this.$[t]=e}getRefId(){return this[E]}typeCheck(){let e=typesModel(this.constructor);return typeCheck(e,this)}toString(e){let t={withData:!0,...e},n=`${this.constructor.name}#${this[z]}`;return t.withData?`[${n} ${JSON.stringify(getSnapshot(this))}]`:`[${n}]`}};let tm=new Set([z,E,"onInit","$","getRefId","onAttachedToRootStore","typeCheck"]);function isModel(e){return e instanceof BaseModel}function isModelClass(e){return"function"==typeof e&&(e===BaseModel||e.prototype instanceof BaseModel)}function isModelSnapshot(e){return isPlainObject(e)&&z in e}function fastGetParentPath(e){return!function(e){createParentPathAtom(e).reportObserved()}(e),ee.get(e)}function fastGetParentPathIncludingDataObjects(e){let t=en.get(e);if(t)return{parent:t,path:"$"};let n=fastGetParentPath(e);return n&&isModel(n.parent)?{parent:n.parent.$,path:n.path}:n}function getParent(e){return assertTweakedObject(e,"value"),fastGetParent(e)}function fastGetParent(e){var t;return null==(t=fastGetParentPath(e))?void 0:t.parent}function isModelDataObject(e){return assertTweakedObject(e,"value",!0),en.has(e)}function fastGetRoot(e){let t,n=e;for(;t=fastGetParentPath(n);)n=t.parent;return n}let tb={resolved:!1};function resolvePath(e,t){let n=e,r=t.length;for(let e=0;e<r;e++){if(!isObject(n))return tb;let r=t[e];if(isArray(n)&&+r>=n.length)return tb;if(isModel(n)){let e=modelToDataNode(n);if(r in e)n=e;else if(!(r in n))return tb}n=n[r]}return{resolved:!0,value:n}}let tg=Symbol("skipIdChecking");function resolvePathCheckingIds(e,t,n){var r;let o=modelToDataNode(e),a=t.length;for(let e=0;e<a;e++){if(!isObject(o))return{resolved:!1};let a=t[e];if(isArray(o)&&+a>=o.length)return{resolved:!1};let l=o[a];o=modelToDataNode(l);let i=n[e];if(i!==tg){let e=isModel(l)&&null!=(r=l[E])?r:null;if(i!==e)return{resolved:!1}}}return{resolved:!0,value:dataToModelNode(o)}}let tv=new WeakMap,tw=new WeakMap;function wrapInAction({nameOrNameFn:e,fn:t,actionType:n,overrideContext:o,isFlowFinisher:a=!1}){let l=!1,wrappedAction=function(){var i;let s;let c="function"==typeof e?e():e;l||(l=!0,t=(0,N.action)(c,t));let u=r,d={actionName:c,type:n,target:this,args:Array.from(arguments),parentContext:u,data:{},rootContext:void 0};o&&o(d,this),d.rootContext||(d.previousAsyncStepContext?d.rootContext=d.previousAsyncStepContext.rootContext:d.parentContext?d.rootContext=d.parentContext.rootContext:d.rootContext=d),r=d;let p=t.bind(this,...arguments),h=(i=d.target,(s=tw.get(i))||(s={[Symbol.iterator](){let e=i;function getCurrentIterator(){let t=e?tv.get(e):void 0;if(t&&!(t.length<=0))return t[Symbol.iterator]()}function findNextIterator(){let t;for(;e&&!t;)e=fastGetParent(e),t=getCurrentIterator();return t}let t=getCurrentIterator();return t||(t=findNextIterator()),{next(){if(!t)return{value:void 0,done:!0};let e=t.next();return e.done?(t=findNextIterator(),this.next()):e}}}},tw.set(i,s)),s)[Symbol.iterator](),f=h.next();for(;!f.done;){let e=f.value,t=!e.filter||e.filter(d);t&&(p=e.middleware.bind(void 0,d,p)),f=h.next()}try{let e=p();if(!a)return e;{let t=e.value;return"accept"===e.resolution?e.accepter(t):e.rejecter(t),t}}finally{r=d.parentContext,function(){if(!r&&!eV){eV=!0;try{for(;eR.length>0;){let e=eR.shift();e()}}finally{eV=!1}}}()}};return wrappedAction[V]=!0,wrappedAction}function wrapModelMethodInActionIfNeeded(e,t,n){let r=e[t];if(isModelAction(r))return;let o=wrapInAction({nameOrNameFn:n,fn:r,actionType:_.Sync}),a=Object.getPrototypeOf(e),l=a[t];l===r?a[t]=o:e[t]=o}function detach(e){assertTweakedObject(e,"node"),tT().call(e)}let tT=lazy(()=>wrapInAction({nameOrNameFn:O.Detach,fn:internalDetach,actionType:_.Sync}));function internalDetach(){let e=fastGetParentPathIncludingDataObjects(this);if(!e)return;let{parent:t,path:n}=e;if((0,N.isObservableArray)(t))t.splice(+n,1);else if((0,N.isObservableObject)(t))(0,N.remove)(t,""+n);else throw failure("parent must be an observable object or an observable array")}let tS=Symbol("modelFlow"),tO=new Map;function internalApplyDelete(e){(0,N.remove)(this,""+e)}function internalApplyMethodCall(e,t){return this[e](...t)}function applySet(e,t,n){assertTweakedObject(e,"node",!0),t_().call(e,t,n)}function internalApplySet(e,t){!isModel(this)&&(0,N.isObservable)(this)?setIfDifferent(this,e,t):this[e]=t}lazy(()=>wrapInAction({nameOrNameFn:O.ApplyDelete,fn:internalApplyDelete,actionType:_.Sync})),lazy(()=>wrapInAction({nameOrNameFn:O.ApplyMethodCall,fn:internalApplyMethodCall,actionType:_.Sync}));let t_=lazy(()=>wrapInAction({nameOrNameFn:O.ApplySet,fn:internalApplySet,actionType:_.Sync}));function modelAction(e,t,n){let{actionName:r,overrideContext:o}=function(e,t){let n,r=t;if(isDataModelClass(e)||isDataModel(e)){let o;n=(e,t)=>{e.target=t.$},r=()=>o;let a=isDataModelClass(e)?e:e.constructor;addLateInitializationFunction(a,ei,e=>{var n,r;let a=Z.get(e);n=o=`fn::${a.name}::${t}`,r=a.class,R.set(n,{modelClass:r,fnName:t})})}return{actionName:r,overrideContext:n}}(e,t);return function(e,t,n){let{target:r,propertyKey:o,baseDescriptor:a}=t,addFieldDecorator=()=>{addLateInitializationFunction(r,U,e=>{let r=n(t,e[o]),a=B in r?r[B]:r,l=a.bind(e);Object.getOwnPropertySymbols(a).forEach(e=>{l[e]=a[e]}),l[B]=a,e[o]=l})};if(a){if(void 0!==a.get)throw failure(`@${e} cannot be used with getters`);if(a.value)return{enumerable:!1,writable:!0,configurable:!0,value:n(t,a.value)};addFieldDecorator()}else addFieldDecorator()}("modelAction",{target:e,propertyKey:t,baseDescriptor:n},(e,t)=>isModelAction(t)?t:(!function(e,t,n){if("function"!=typeof n)throw failure("modelAction has to be used over functions");!function(e,t,n){if("string"!=typeof n)throw failure(`${e} cannot be used over symbol properties`);let r=`${e} must be used over model classes or instances`;if(!t)throw failure(r);let o=t instanceof BaseModel||t===BaseModel||t.prototype instanceof BaseModel;if(o)return;let a=t instanceof BaseDataModel||t===BaseDataModel||t.prototype instanceof BaseDataModel;if(!a)throw failure(r)}("modelAction",e,t)}(e.target,e.propertyKey,t),wrapInAction({nameOrNameFn:r,fn:t,actionType:_.Sync,overrideContext:o})))}function __decorate(e,t,n,r){var o,a=arguments.length,l=a<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)l=Reflect.decorate(e,t,n,r);else for(var i=e.length-1;i>=0;i--)(o=e[i])&&(l=(a<3?o(l):a>3?o(t,n,l):o(t,n))||l);return a>3&&l&&Object.defineProperty(t,n,l),l}O.ApplySnapshot,O.ApplyPatches,O.Detach,O.ApplySet,O.ApplyDelete,O.ApplyMethodCall,Symbol("cannotSerialize"),(y=F||(F={})).Return="return",y.Throw="throw",Symbol("simpleDataContext"),"function"==typeof SuppressedError&&SuppressedError;let ObjectTypeInfo=class ObjectTypeInfo extends TypeInfo{constructor(e,t){super(e),__publicField(this,"_objTypeFn"),__publicField(this,"_props",lazy(()=>{let e=this._objTypeFn(),t={};return Object.keys(e).forEach(n=>{let r=resolveStandardType(e[n]);t[n]={type:r,typeInfo:getTypeInfo(r)}}),t})),this._objTypeFn=t}get props(){return this._props()}};let tk=new TypeChecker(C.Any,null,()=>"any",e=>new UncheckedTypeInfo(e),()=>tk,identityFn,identityFn);function typesUnchecked(){return tk}let UncheckedTypeInfo=class UncheckedTypeInfo extends TypeInfo{};let OrTypeInfo=class OrTypeInfo extends TypeInfo{constructor(e,t){super(e),__publicField(this,"orTypes"),__publicField(this,"_orTypeInfos",lazy(()=>this.orTypes.map(getTypeInfo))),this.orTypes=t}get orTypeInfos(){return this._orTypeInfos()}};let tC=Symbol("noDefaultValue"),tP=new WeakMap;function tProp(e,t){var n;let r,o;switch(typeof e){case"string":return tProp(ek,e);case"number":return tProp(e_,e);case"boolean":return tProp(eO,e)}let a=arguments.length>=2,l=resolveStandardType(e);return n=a?t:tC,(r=tP.get(l))||(r=new Map,tP.set(l,r)),(o=r.get(n))||(o=(()=>{let e=a?function(e,...t){let n;let r=t.slice(),o=resolveStandardTypeNoThrow(e);if(o?r.unshift(o):n=t=>{let n=e(t),r=resolveTypeChecker(n);return r},r.length<=0)throw failure("or type must have at least 1 possible type");let typeInfoGen=e=>new OrTypeInfo(e,r.map(resolveStandardType));return lateTypeChecker(()=>{let e;let t=r.map(resolveTypeChecker);if(t.some(e=>e.unchecked))return typesUnchecked();let getTypeName=(...e)=>{let n=t.map(t=>e.includes(t)?"...":t.getTypeName(...e,t));return n.join(" | ")};e=t.some(e=>e.baseType!==t[0].baseType)?C.Any:t[0].baseType;let o=new TypeChecker(e,(e,n,r)=>{let a=t.some(t=>!t.check(e,n,r));return a?null:new TypeCheckError(n,getTypeName(o),e,r)},getTypeName,typeInfoGen,e=>{let n=isArray(e)?C.Array:isObject(e)?C.Object:isPrimitive(e)?C.Primitive:C.Any,r=t.filter(e=>e.baseType===n||e.baseType===C.Any);if(1===r.length&&r[0].baseType===n)return r[0];for(let t=0;t<r.length;t++){let n=r[t].snapshotType(e);if(n)return n}return null},e=>{let t=n?n(e):o.snapshotType(e);if(!t)throw failure(`snapshot '${JSON.stringify(e)}' does not match the following type: ${getTypeName(o)}`);return t.fromSnapshotProcessor(e)},e=>{let t=n?n(e):o.snapshotType(e);if(!t)throw failure(`snapshot '${JSON.stringify(e)}' does not match the following type: ${getTypeName(o)}`);return t.toSnapshotProcessor(e)});return o},typeInfoGen)}(l,eT,eS):l,n=Object.create(a?prop(t):prop());return Object.assign(n,{_typeChecker:l,_fromSnapshotProcessor:tPropFromSnapshotProcessor.bind(void 0,e),_toSnapshotProcessor:tPropToSnapshotProcessor.bind(void 0,l)}),n})(),r.set(n,o)),o}function tPropFromSnapshotProcessor(e,t){let n=resolveTypeChecker(e).fromSnapshotProcessor;return n?n(t):t}function tPropToSnapshotProcessor(e,t){let n=resolveTypeChecker(e).toSnapshotProcessor;return n?n(t):t}function chainFns(...e){let t=e.filter(e=>!!e);if(!(t.length<=0))return(e,...n)=>{let r=e;for(let e=0;e<t.length;e++)r=t[e](r,...n);return r}}function assertIsClassOrDataModelClass(e,t,n="must be a class or data model class"){if(!isModelClass(e)&&!isDataModelClass(e))throw failure(`${t} ${n}`)}let idGenerator=()=>eN.modelIdGenerator(),tI=tProp(ek,idGenerator);tI._isId=!0;let tM=prop(idGenerator);function Model(e,t){var n;let o="function"==typeof e?e():e;return function({modelProps:e,baseModel:t,type:n,valueType:o,fromSnapshotProcessor:a,toSnapshotProcessor:l}){var i,s,c;let u,d,p;if(assertIsObject(e,"modelProps"),e=Object.assign(Object.create(null),e),t){assertIsClassOrDataModelClass(t,"baseModel");let e=t[el];e&&assertIsClassOrDataModelClass(t=e,"baseModel")}let h=e;if(t){let n=t[ec];for(let t of Object.keys(n))e[t]||(h[t]=n[t])}let f=Object.keys(h).filter(e=>{let t=h[e];return t._isId});if("class"===n){if(f.length>1)throw failure(`expected at most one idProp but got many: ${JSON.stringify(f)}`)}else if(f.length>=1)throw failure(`expected no idProp but got some: ${JSON.stringify(f)}`);let y=Object.values(h).some(e=>!!e._typeChecker);if(f.length>=1){u=f[0];let e=h[u],t=y?tI:tM;switch(null==e?void 0:e._setter){case!0:t=t.withSetter();break;case"assign":t=t.withSetter("assign")}h[u]=t}if(y){let e={};for(let[t,n]of Object.entries(h))e[t]=n._typeChecker?n._typeChecker:typesUnchecked();s=i=()=>e,c=e=>new ObjectTypeInfo(e,i),assertIsFunction(s,"objFn"),d=lateTypeChecker(()=>{let e=s();assertIsObject(e,"objectSchema");let t=Object.entries(e),getTypeName=(...e)=>{let n=[];for(let[r,o]of t){let t=resolveTypeChecker(o),a="...";e.includes(t)||(a=t.getTypeName(...e,t)),n.push(`${r}: ${a};`)}return`{ ${n.join(" ")} }`},applySnapshotProcessor=(t,n)=>{let r={},o=Object.keys(t);for(let a=0;a<o.length;a++){let l=o[a],i=e[l];if(i){let e=resolveTypeChecker(i);r[l]="from"===n?e.fromSnapshotProcessor(t[l]):e.toSnapshotProcessor(t[l])}else r[l]=t[l]}return r},n=new TypeChecker(C.Object,(e,r,o)=>{if(!isObject(e))return new TypeCheckError(r,getTypeName(n),e,o);for(let[n,a]of t){let t=resolveTypeChecker(a),l=e[n],i=t.check(l,[...r,n],o);if(i)return i}return null},getTypeName,c,e=>{if(!isObject(e))return null;for(let[n,r]of t){let t=resolveTypeChecker(r),o=e[n],a=t.snapshotType(o);if(!a)return null}return n},e=>applySnapshotProcessor(e,"from"),e=>applySnapshotProcessor(e,"to"));return n},c)}let m=null!=t?t:"class"===n?BaseModel:BaseDataModel,b="class"===n?tm:e6;function ThisModel(e,t){var n;let r=null!=(n=null==t?void 0:t.modelClass)?n:this.constructor,o=new m(e,{...t,modelClass:r});return p||(p=Object.keys(h).filter(e=>!b.has(e)&&Object.hasOwn(o,e))),p.forEach(e=>delete o[e]),o}Object.assign(ThisModel,m);let g=m[e$];if(g&&(ThisModel[e$]=g.slice()),ThisModel[ec]=h,"class"===n){let e={dataType:d,modelIdProperty:u,valueType:o};ThisModel[ea]=e}else{let e={dataType:d};ThisModel[ea]=e}let v=Object.create(m.prototype);for(let[t,n]of(ThisModel.prototype=new Proxy(v,{get(e,t,n){if(n===ThisModel.prototype)return e[t];let r=!b.has(t)&&h[t];return r?function(e,t,n){let r=e.$[n];return t._transform?t._transform.transform(r,e,n,t=>{applySet(e.$,n,t)}):r}(n,r,t):Reflect.get(e,t,n)},set(e,t,n,o){if(o===ThisModel.prototype)return e[t]=n,!0;let a=!b.has(t)&&h[t];return a?(function(e,t,n,o){if(!(X in e))return;if("assign"===t._setter&&!r){applySet(e,n,o);return}let a=t._transform?t._transform.untransform(o,e,n):o;if(null==a){let e=getModelPropDefaultValue(t);e!==eu&&(a=e)}e.$[n]=a}(o,a,t,n),!0):Reflect.set(e,t,n,o)},has(e,t){let n=!b.has(t)&&h[t];return!!n||Reflect.has(e,t)}}),v.constructor=ThisModel,Object.entries(e)))if(!0===n._setter){let e=`set${t[0].toUpperCase()}${t.slice(1)}`,n=modelAction(v,e,{value:function(e){this[t]=e},writable:!0,enumerable:!1,configurable:!0});Object.defineProperty(v,e,n)}let w=function(e){let t=Object.entries(e).filter(([e,t])=>t._fromSnapshotProcessor);if(!(t.length<=0))return e=>{let n={...e};for(let[r,o]of t)o._fromSnapshotProcessor&&(n[r]=o._fromSnapshotProcessor(e[r]));return n}}(h),T=function(e){let t=Object.entries(e).filter(([e,t])=>t._toSnapshotProcessor);if(!(t.length<=0))return e=>{let n={...e};for(let[r,o]of t)o._toSnapshotProcessor&&(n[r]=o._toSnapshotProcessor(e[r]));return n}}(h);if(a){let e=a;a=t=>({...e(t),[z]:t[z]})}if(l){let e=l;l=(t,n)=>({...e(t,n),[z]:t[z]})}return ThisModel.fromSnapshotProcessor=chainFns(a,w),ThisModel.toSnapshotProcessor=chainFns(T,l),ThisModel}({modelProps:o,baseModel:void 0,type:"class",valueType:null!=(n=null==t?void 0:t.valueType)&&n,fromSnapshotProcessor:null==t?void 0:t.fromSnapshotProcessor,toSnapshotProcessor:null==t?void 0:t.toSnapshotProcessor})}tM._isId=!0;let model=e=>t=>internalModel(e)(t),tj=new WeakMap,tA={construct(e,t){let n=new e(...t);runLateInitializationFunctions(n,U);let r=tj.get(e);if(!r.makeObservableFailed&&getMobxVersion()>=6)try{J.makeObservable(n)}catch(e){if(r.makeObservableFailed=!0,"[MobX] No annotations were passed to makeObservable, but no decorator members have been found either"!==e.message&&"[MobX] No annotations were passed to makeObservable, but no decorated members have been found either"!==e.message)throw e}return addHiddenProp(n,X,!0,!1),runLateInitializationFunctions(n,L),"class"===r.type&&n.onInit&&(wrapModelMethodInActionIfNeeded(n,"onInit",I.OnInit),n.onInit()),"data"===r.type&&n.onLazyInit&&(wrapModelMethodInActionIfNeeded(n,"onLazyInit",I.OnLazyInit),n.onLazyInit()),n}},internalModel=e=>t=>{let n=isModelClass(t)?"class":isDataModelClass(t)?"data":void 0;if(!n)throw failure("clazz must be a class that extends from Model/DataModel");if(Y[e]&&eN.showDuplicateModelNameWarnings&&logWarning("warn",`a model with name "${e}" already exists (if you are using hot-reloading you may safely ignore this warning)`,`duplicateModelName - ${e}`),el in t&&t[el]===t)throw failure("a class already decorated with `@model` cannot be re-decorated");tj.set(t,{makeObservableFailed:!1,type:n});let r=new Proxy(t,tA);t.toString=()=>`class ${t.name}#${e}`,"class"===n&&(t[z]=e),r.prototype.constructor=r,r[el]=t;let o={name:e,class:r};return Y[e]=o,Z.set(r,o),Z.set(t,o),runLateInitializationFunctions(t,ei),r};function typesArray(e){let typeInfoGen=t=>new ArrayTypeInfo(t,resolveStandardType(e));return lateTypeChecker(()=>{let t=resolveTypeChecker(e),getTypeName=(...e)=>`Array<${t.getTypeName(...e,t)}>`,n=new TypeChecker(C.Array,(e,r,o)=>{if(!isArray(e))return new TypeCheckError(r,getTypeName(n),e,o);if(!t.unchecked)for(let n=0;n<e.length;n++){let a=t.check(e[n],[...r,n],o);if(a)return a}return null},getTypeName,typeInfoGen,e=>{if(!isArray(e))return null;if(!t.unchecked)for(let n=0;n<e.length;n++){let r=t.snapshotType(e[n]);if(!r)return null}return n},e=>t.unchecked?e:e.map(e=>t.fromSnapshotProcessor(e)),e=>t.unchecked?e:e.map(e=>t.toSnapshotProcessor(e)));return n},typeInfoGen)}let ArrayTypeInfo=class ArrayTypeInfo extends TypeInfo{constructor(e,t){super(e),__publicField(this,"itemType"),this.itemType=t}get itemTypeInfo(){return getTypeInfo(this.itemType)}};function toSingleEvents(e,t){if(e.type===x.Single)return[e];{let n=[];for(let r of e.events)t?n.unshift(...toSingleEvents(r,!0)):n.push(...toSingleEvents(r,!1));return n}}(m=x||(x={})).Single="single",m.Group="group";let tD=class extends Model({undoEvents:tProp(typesArray(typesUnchecked()),()=>[]),redoEvents:tProp(typesArray(typesUnchecked()),()=>[])}){constructor(){super(...arguments),__publicField(this,"_groupStack",[])}_clearUndo(){withoutUndo(()=>{this.undoEvents.length=0})}_clearRedo(){withoutUndo(()=>{this.redoEvents.length=0})}enforceMaxLevels({maxUndoLevels:e,maxRedoLevels:t}){if(void 0!==e)for(;this.undoEvents.length>e;)this.undoEvents.shift();if(void 0!==t)for(;this.redoEvents.length>t;)this.redoEvents.shift()}_undo({maxRedoLevels:e}){withoutUndo(()=>{let t=this.undoEvents.pop();this.redoEvents.push(t),this.enforceMaxLevels({maxRedoLevels:e})})}_redo({maxUndoLevels:e}){withoutUndo(()=>{let t=this.redoEvents.pop();this.undoEvents.push(t),this.enforceMaxLevels({maxUndoLevels:e})})}_addUndo({event:e,maxUndoLevels:t}){withoutUndo(()=>{this.undoEvents.push(e),this.redoEvents.length=0,this.enforceMaxLevels({maxUndoLevels:t})})}_addUndoToParentGroup(e,t){e.events.push(t)}get _currentGroup(){return this._groupStack[this._groupStack.length-1]}_startGroup(e,t,n){var r;let o=!1,a=!1,l=this._currentGroup,i={type:x.Group,groupName:e,events:[]},s=l?void 0:null==(r=null==n?void 0:n.attachedState)?void 0:r.save(),c={pause:()=>{if(a)throw failure("cannot pause a group when it is already ended");if(!o)throw failure("cannot pause a group when it is not running");if(this._currentGroup!==i)throw failure("group out of order");this._groupStack.pop(),o=!1},resume:()=>{if(a)throw failure("cannot resume a group when it is already ended");if(o)throw failure("cannot resume a group when it is already running");this._groupStack.push(i),o=!0},end:()=>{var e;o&&c.pause(),a=!0,l?this._addUndoToParentGroup(l,i):this._addUndo({event:{...i,attachedState:{beforeEvent:s,afterEvent:null==(e=null==n?void 0:n.attachedState)?void 0:e.save()}},maxUndoLevels:null==n?void 0:n.maxUndoLevels})}};return t&&c.resume(),c}};__decorate([modelAction],tD.prototype,"_clearUndo",null),__decorate([modelAction],tD.prototype,"_clearRedo",null),__decorate([modelAction],tD.prototype,"_undo",null),__decorate([modelAction],tD.prototype,"_redo",null),__decorate([modelAction],tD.prototype,"_addUndo",null),tD=__decorate([model(`${Q}/UndoStore`)],tD);let UndoManager=class UndoManager{constructor(e,t,n,r){__publicField(this,"disposer"),__publicField(this,"subtreeRoot"),__publicField(this,"options"),__publicField(this,"store"),__publicField(this,"_isUndoRecordingDisabled",!1),this.disposer=e,this.subtreeRoot=t,this.options=r,getMobxVersion()>=6&&J.makeObservable(this),this.store=null!=n?n:new tD({})}get undoQueue(){return this.store.undoEvents}get redoQueue(){return this.store.redoEvents}get undoLevels(){return this.undoQueue.length}get canUndo(){return this.undoLevels>0}clearUndo(){this.store._clearUndo()}get redoLevels(){return this.redoQueue.length}get canRedo(){return this.redoLevels>0}clearRedo(){this.store._clearRedo()}undo(){var e;if(!this.canUndo)throw failure("nothing to undo");let t=this.undoQueue[this.undoQueue.length-1];withoutUndo(()=>{var e,n,r;toSingleEvents(t,!0).forEach(e=>{applyPatches(this.subtreeRoot,e.inversePatches,!0)}),(null==(e=t.attachedState)?void 0:e.beforeEvent)&&(null==(r=null==(n=this.options)?void 0:n.attachedState)||r.restore(t.attachedState.beforeEvent))}),this.store._undo({maxRedoLevels:null==(e=this.options)?void 0:e.maxRedoLevels})}redo(){var e;if(!this.canRedo)throw failure("nothing to redo");let t=this.redoQueue[this.redoQueue.length-1];withoutUndo(()=>{var e,n,r;toSingleEvents(t,!1).forEach(e=>{applyPatches(this.subtreeRoot,e.patches)}),(null==(e=t.attachedState)?void 0:e.afterEvent)&&(null==(r=null==(n=this.options)?void 0:n.attachedState)||r.restore(t.attachedState.afterEvent))}),this.store._redo({maxUndoLevels:null==(e=this.options)?void 0:e.maxUndoLevels})}dispose(){this.disposer()}get isUndoRecordingDisabled(){return this._isUndoRecordingDisabled}withoutUndo(e){let t=this._isUndoRecordingDisabled;this._isUndoRecordingDisabled=!0;try{return e()}finally{this._isUndoRecordingDisabled=t}}createGroup(e){let t=this.store._startGroup(e,!1,this.options);return{continue(e){t.resume();try{return e()}finally{t.pause()}},end(){t.end()}}}withGroup(e,t){let n,r;"string"==typeof e?(n=e,r=t):r=e;let o=this.store._startGroup(n,!0,this.options);try{return r()}finally{o.end()}}withGroupFlow(e,t){let n,r;"string"==typeof e?(n=e,r=t):r=e;let o=r(),a=this.store._startGroup(n,!1,this.options),l=o.next.bind(o),i=o.throw.bind(o),s=new Promise(function(e,t){function onFulfilled(e){let n;a.resume();try{n=l(e)}catch(e){a.end(),t(e);return}a.pause(),next(n)}function onRejected(e){let n;a.resume();try{n=i(e)}catch(e){a.end(),t(e);return}a.pause(),next(n)}function next(n){n&&"function"==typeof n.then?n.then(next,t):n.done?(a.end(),e(n.value)):Promise.resolve(n.value).then(onFulfilled,onRejected)}onFulfilled(void 0)});return s}};__decorate([N.computed],UndoManager.prototype,"undoQueue",null),__decorate([N.computed],UndoManager.prototype,"redoQueue",null),__decorate([N.computed],UndoManager.prototype,"undoLevels",null),__decorate([N.computed],UndoManager.prototype,"canUndo",null),__decorate([N.action],UndoManager.prototype,"clearUndo",null),__decorate([N.computed],UndoManager.prototype,"redoLevels",null),__decorate([N.computed],UndoManager.prototype,"canRedo",null),__decorate([N.action],UndoManager.prototype,"clearRedo",null),__decorate([N.action],UndoManager.prototype,"undo",null),__decorate([N.action],UndoManager.prototype,"redo",null);let tF=!1;function withoutUndo(e){let t=tF;tF=!0;try{return e()}finally{tF=t}}function resolveContextValue(e){return"value"===e.type?e.value:e.value.get()}let createContextValueAtom=()=>(0,N.createAtom)("contextValue");let ContextClass=class ContextClass{constructor(e){__publicField(this,"defaultContextValue",N.observable.box(void 0,{deep:!1})),__publicField(this,"overrideContextValue",N.observable.box(void 0,{deep:!1})),__publicField(this,"nodeContextValue",new WeakMap),__publicField(this,"nodeAtom",new WeakMap),__publicField(this,"setDefault",(0,N.action)(e=>{this.defaultContextValue.set({type:"value",value:e})})),__publicField(this,"setDefaultComputed",(0,N.action)(e=>{this.defaultContextValue.set({type:"computed",value:(0,N.computed)(e)})})),__publicField(this,"set",(0,N.action)((e,t)=>{assertTweakedObject(e,"node"),this.nodeContextValue.set(e,{type:"value",value:t}),this.getNodeAtom(e).reportChanged()})),__publicField(this,"setComputed",(0,N.action)((e,t)=>{this._setComputed(e,(0,N.computed)(t))})),__publicField(this,"unset",(0,N.action)(e=>{assertTweakedObject(e,"node"),this.nodeContextValue.delete(e),this.getNodeAtom(e).reportChanged()})),__publicField(this,"apply",(0,N.action)((e,t)=>{let n=this.overrideContextValue.get();this.overrideContextValue.set({type:"value",value:t});try{let n=e();return isTweakedObject(n,!0)&&this.set(n,t),n}finally{this.overrideContextValue.set(n)}})),__publicField(this,"applyComputed",(0,N.action)((e,t)=>{let n=(0,N.computed)(t),r=this.overrideContextValue.get();this.overrideContextValue.set({type:"computed",value:n});try{let t=e();return isTweakedObject(t,!0)&&this._setComputed(t,n),t}finally{this.overrideContextValue.set(r)}})),this.setDefault(e)}getNodeAtom(e){return getOrCreate(this.nodeAtom,e,createContextValueAtom)}fastGet(e){this.getNodeAtom(e).reportObserved();let t=this.nodeContextValue.get(e);if(t)return resolveContextValue(t);let n=fastGetParent(e);if(!n){let e=this.overrideContextValue.get();return e?resolveContextValue(e):this.getDefault()}return this.fastGet(n)}get(e){return assertTweakedObject(e,"node"),this.fastGet(e)}fastGetProviderNode(e){this.getNodeAtom(e).reportObserved();let t=this.nodeContextValue.get(e);if(t)return e;let n=fastGetParent(e);if(n)return this.fastGetProviderNode(n)}getProviderNode(e){return assertTweakedObject(e,"node"),this.fastGetProviderNode(e)}getDefault(){return resolveContextValue(this.defaultContextValue.get())}_setComputed(e,t){assertTweakedObject(e,"node"),this.nodeContextValue.set(e,{type:"computed",value:t}),this.getNodeAtom(e).reportChanged()}};new ContextClass(!1);let Ref=class Ref extends Model({id:tProp(ek)}){get maybeCurrent(){return this.resolve()}get isValid(){return!!this.maybeCurrent}get current(){let e=this.maybeCurrent;if(!e)throw failure(`a reference of type '${this[z]}' could not resolve an object with id '${this.id}'`);return e}};__decorate([N.computed],Ref.prototype,"maybeCurrent",null),__decorate([N.computed],Ref.prototype,"isValid",null),__decorate([N.computed],Ref.prototype,"current",null);let tx=new WeakMap;function internalCustomRef(e,t,n,r){let o=class extends Ref{constructor(){super(...arguments),__publicField(this,"resolver"),__publicField(this,"savedOldTarget")}resolve(){return this.resolver||(this.resolver=t(this)),this.resolver(this)}internalForceUpdateBackRefs(e){let t=this.savedOldTarget;this.savedOldTarget=e,t$(this,a,e,t)}forceUpdateBackRefs(){this.internalForceUpdateBackRefs(this.maybeCurrent)}onInit(){let e;let t=!0;(0,N.reaction)(()=>this.maybeCurrent,n=>{this.internalForceUpdateBackRefs(n);let o=e,a=t;e=n,t=!1,!a&&r&&n!==o&&r(this,n,o)},{fireImmediately:!0})}};__decorate([N.action],o.prototype,"forceUpdateBackRefs",null),o=__decorate([model(e)],o);let fn=e=>{let t;if("string"==typeof e?t=e:(assertIsObject(e,"target"),t=n(e)),"string"!=typeof t)throw failure("ref target object must have an id of string type");let r=new o({id:t});return r};fn.refClass=o;let a=fn;return a}function getModelRefId(e){if(isModel(e)&&e.getRefId){let t=e.getRefId();if(void 0!==t&&"string"!=typeof t)throw failure("'getRefId()' must return a string or undefined when present");return t}}let tN=new WeakMap;function getBackRefs(e,t){let n=tx.get(e);if(n||(n={all:N.observable.set(void 0,{deep:!1}),byType:new WeakMap},tx.set(e,n)),!t)return n.all;{let e=n.byType.get(t);return e||(e=N.observable.set(void 0,{deep:!1}),n.byType.set(t,e)),e}}let t$=(0,N.action)("updateBackRefs",(e,t,n,r)=>{n!==r&&(r&&(getBackRefs(r).delete(e),getBackRefs(r,t).delete(e)),n&&(getBackRefs(n).add(e),getBackRefs(n,t).add(e)))});registerDeepObjectChildrenExtension({initData:()=>({all:new Set,byType:new WeakMap}),addNode(e,t){if(e instanceof Ref){t.all.add(e);let n=getOrCreate(t.byType,e.constructor,()=>new Set);n.add(e)}}});let tR=(0,N.action)("customRef",(e,t)=>{var n;let r=null!=(n=t.getId)?n:getModelRefId;return internalCustomRef(e,()=>t.resolve,r,t.onResolvedValueChange)});function standaloneAction(e,t){return function(e,t,n){if(assertIsFunction(t,e),tO.has(e)&&logWarning("warn",`an standalone action with name "${e}" already exists (if you are using hot-reloading you may safely ignore this warning)`,`duplicateActionName - ${e}`),isModelAction(t))throw failure("the standalone action must not be previously marked as an action");if("function"==typeof t&&tS in t)throw failure("the standalone action must not be previously marked as a flow action");let r=n?function({nameOrNameFn:e,generator:t,overrideContext:n}){let flowFn=function(...r){let o;let a="function"==typeof e?e():e,l=this,ctxOverride=e=>(t,a)=>{n&&n(t,a),t.previousAsyncStepContext=o,t.spawnAsyncStepContext=o?o.spawnAsyncStepContext:t,t.asyncStepType=e,t.args=r,o=t},i=!1,s=wrapInAction({nameOrNameFn:a,fn:()=>(i=!0,t.apply(l,r)),actionType:_.Async,overrideContext:ctxOverride(k.Spawn)}).apply(l);if(!i)return s instanceof Promise?s:Promise.resolve(s);let c=s.next.bind(s),u=s.throw.bind(s),d=new Promise(function(e,t){function onFulfilled(n){let r;try{r=wrapInAction({nameOrNameFn:a,fn:c,actionType:_.Async,overrideContext:ctxOverride(k.Resume)}).call(l,n)}catch(n){wrapInAction({nameOrNameFn:a,fn:n=>({value:n,resolution:"reject",accepter:e,rejecter:t}),actionType:_.Async,overrideContext:ctxOverride(k.Throw),isFlowFinisher:!0}).call(l,n);return}next(r)}function onRejected(n){let r;try{r=wrapInAction({nameOrNameFn:a,fn:u,actionType:_.Async,overrideContext:ctxOverride(k.ResumeError)}).call(l,n)}catch(n){wrapInAction({nameOrNameFn:a,fn:n=>({value:n,resolution:"reject",accepter:e,rejecter:t}),actionType:_.Async,overrideContext:ctxOverride(k.Throw),isFlowFinisher:!0}).call(l,n);return}next(r)}function next(n){n&&"function"==typeof n.then?n.then(next,t):n.done?wrapInAction({nameOrNameFn:a,fn:n=>({value:n,resolution:"accept",accepter:e,rejecter:t}),actionType:_.Async,overrideContext:ctxOverride(k.Return),isFlowFinisher:!0}).call(l,n.value):Promise.resolve(n.value).then(onFulfilled,onRejected)}onFulfilled(void 0)});return d};return flowFn[tS]=!0,flowFn}({nameOrNameFn:e,generator:t}):wrapInAction({nameOrNameFn:e,fn:t,actionType:_.Sync}),finalAction=(e,...t)=>(!function(e,t="argument"){assertTweakedObject(e,t,!1)}(e,"target"),r.call(e,e,...t));return tO.set(e,finalAction),finalAction}(e,t,!1)}(0,N.action)("rootRef",(e,t)=>{var n;let r=null!=(n=null==t?void 0:t.getId)?n:getModelRefId,o=null==t?void 0:t.onResolvedValueChange;return internalCustomRef(e,e=>{let t;return()=>{var n;let o=fastGetRoot(e);if((n=t)&&e.id===r(n)&&o===fastGetRoot(n))return t;let a=function(e,t,n=getModelRefId){let r=getOrCreate(tN,n,()=>(function(e){let t=new WeakMap;return{walk:n=>(function getComputedTreeResult(e,t,n){let r=e.get(n);return r||(r=(0,N.computed)(()=>(function(e,t,n){let r;let o=t(e),a=getObjectChildren(e),l=a.values(),i=l.next();if(void 0===o&&1===a.size)return n(i.value);for(;!i.done;){let e=n(i.value);if(e){r||(r=new Map);let t=e.keys(),n=t.next();for(;!n.done;){let o=n.value,a=e.get(o);r.set(o,a),n=t.next()}}i=l.next()}return void 0!==o&&(r||(r=new Map),r.set(o,e)),r})(n,t,n=>getComputedTreeResult(e,t,n))),e.set(n,r)),r.get()})(t,e,n)}})(e=>n(e))),o=r.walk(e);return o?o.get(t):void 0}(o,e.id,r);return a&&(t=a),a}},r,o)});let tV=`${Q}/arrayActions`;standaloneAction(`${tV}::set`,(e,t,n)=>{setIfDifferent(e,t,n)}),standaloneAction(`${tV}::delete`,(e,t)=>(0,N.remove)(e,""+t)),standaloneAction(`${tV}::setLength`,(e,t)=>{e.length=t}),standaloneAction(`${tV}::concat`,(e,...t)=>e.concat(...t)),standaloneAction(`${tV}::copyWithin`,(e,t,n,r)=>e.copyWithin(t,n,r)),standaloneAction(`${tV}::fill`,(e,t,n,r)=>e.fill(t,n,r)),standaloneAction(`${tV}::pop`,e=>e.pop()),standaloneAction(`${tV}::push`,(e,...t)=>e.push(...t)),standaloneAction(`${tV}::reverse`,e=>e.reverse()),standaloneAction(`${tV}::shift`,e=>e.shift()),standaloneAction(`${tV}::slice`,(e,t,n)=>e.slice(t,n)),standaloneAction(`${tV}::sort`,(e,t)=>e.sort(t)),standaloneAction(`${tV}::splice`,function(e,...t){return e.splice(...t)}),standaloneAction(`${tV}::unshift`,(e,...t)=>e.unshift(...t)),standaloneAction(`${tV}::swap`,(e,t,n)=>{if(t<0||n<0||t>=e.length||n>=e.length)return!1;n<t&&([t,n]=[n,t]);let[r]=e.splice(t,1),[o]=e.splice(n-1,1);return e.splice(t,0,o),e.splice(n,0,r),!0}),e=>toTreeNode(e);let tz=`${Q}/objectActions`;function tag(e){let t=new WeakMap;return{for(n){if(t.has(n))return t.get(n);{let r=e(n);return t.set(n,r),r}}}}standaloneAction(`${tz}::set`,(e,t,n)=>{(0,N.isObservable)(e)?setIfDifferent(e,t,n):e[t]=n}),standaloneAction(`${tz}::assign`,(e,t)=>{assertIsObject(t,"partialObject");let n=Object.keys(t);if((0,N.isObservable)(e))for(let r of n){let n=t[r];setIfDifferent(e,r,n)}else for(let r of n)e[r]=t[r]}),standaloneAction(`${tz}::delete`,(e,t)=>(0,N.remove)(e,t)),standaloneAction(`${tz}::call`,(e,t,...n)=>e[t](...n)),e=>toTreeNode(e);let tE=(0,N.action)(e=>{let t=N.observable.map();t.dataObject=e;let n=Object.keys(e);for(let r=0;r<n.length;r++){let o=n[r];t.set(o,e[o])}let r=!1,o=!1;return(0,N.observe)(e,(0,N.action)(e=>{if(!r){o=!0;try{switch(e.type){case"add":case"update":t.set(e.name,e.newValue);break;case"remove":t.delete(e.name)}}finally{o=!1}}})),(0,N.intercept)(t,(0,N.action)(t=>{if(r)return null;if(o)return t;r=!0;try{switch(t.type){case"add":case"update":setIfDifferent(e,t.name,t.newValue);break;case"delete":(0,N.remove)(e,t.name)}return t}finally{r=!1}})),t}),tG=(0,N.action)(e=>{let t;if(getMobxVersion()>=6?t=N.observable.map(e):(t=N.observable.map(),e.forEach(([e,n])=>{t.set(e,n)})),t.dataObject=e,t.size!==e.length)throw failure("arrays backing a map cannot contain duplicate keys");let n=!1,r=!1;return(0,N.observe)(e,(0,N.action)(e=>{if(!n){r=!0;try{switch(e.type){case"splice":{let n=e.removed;for(let e=0;e<n.length;e++)t.delete(n[e][0])}{let n=e.added;for(let e=0;e<n.length;e++)t.set(n[e][0],n[e][1])}break;case"update":t.delete(e.oldValue[0]),t.set(e.newValue[0],e.newValue[1])}}finally{r=!1}}})),(0,N.intercept)(t,(0,N.action)(t=>{if(n)return null;if(r)return t;n=!0;try{switch(t.type){case"update":{let n=e.findIndex(e=>e[0]===t.name);e[n]=[t.name,t.newValue];break}case"add":e.push([t.name,t.newValue]);break;case"delete":{let n=e.findIndex(e=>e[0]===t.name);n>=0&&e.splice(n,1)}}return t}finally{n=!1}})),t});tag(e=>isArray(e)?(assertIsObservableArray(e,"objOrArray"),tG(e)):(!function(e,t){if(!(0,N.isObservableObject)(e))throw failure(`${t} must be an observable object`)}(e,"objOrArray"),tE(e)));let tU=(0,N.action)(e=>{let t;if(getMobxVersion()>=6?t=N.observable.set(e):(t=N.observable.set(),e.forEach(e=>{t.add(e)})),t.dataObject=e,t.size!==e.length)throw failure("arrays backing a set cannot contain duplicate values");let n=!1,r=!1;return(0,N.observe)(e,(0,N.action)(e=>{if(!n){r=!0;try{switch(e.type){case"splice":{let n=e.removed;for(let e=0;e<n.length;e++)t.delete(n[e])}{let n=e.added;for(let e=0;e<n.length;e++)t.add(n[e])}break;case"update":t.delete(e.oldValue),t.add(e.newValue)}}finally{r=!1}}})),(0,N.intercept)(t,(0,N.action)(t=>{if(n)return null;if(r)return t;n=!0;try{switch(t.type){case"add":e.push(t.newValue);break;case"delete":{let n=e.indexOf(t.oldValue);n>=0&&e.splice(n,1)}}return t}finally{n=!1}})),t});tag(e=>(assertIsObservableArray(e,"array"),tU(e)));let tL="this Date object is immutable";let ImmutableDate=class ImmutableDate extends Date{setTime(){throw failure(tL)}setMilliseconds(){throw failure(tL)}setUTCMilliseconds(){throw failure(tL)}setSeconds(){throw failure(tL)}setUTCSeconds(){throw failure(tL)}setMinutes(){throw failure(tL)}setUTCMinutes(){throw failure(tL)}setHours(){throw failure(tL)}setUTCHours(){throw failure(tL)}setDate(){throw failure(tL)}setUTCDate(){throw failure(tL)}setMonth(){throw failure(tL)}setUTCMonth(){throw failure(tL)}setFullYear(){throw failure(tL)}setUTCFullYear(){throw failure(tL)}};let tB={transform:({originalValue:e,cachedTransformedValue:t})=>null!=t?t:new ImmutableDate(e),untransform:({transformedValue:e,cacheTransformedValue:t})=>(e instanceof ImmutableDate&&t(),+e)},timestampToDateTransform=()=>tB;let Draft=class Draft{constructor(e){__publicField(this,"data"),__publicField(this,"originalData"),assertTweakedObject(e,"original"),this.originalData=e,this.data=fromSnapshot(this.originalSnapshot,{generateNewIds:!1})}commit(){applySnapshot(this.originalData,getSnapshot(this.data))}commitByPath(e){let t=resolvePath(this.data,e);if(!t.resolved)throw failure(`path ${JSON.stringify(e)} could not be resolved in draft object`);let n=pathToTargetPathIdsIgnoringLast(this.data,e),r=resolvePathCheckingIds(this.originalData,e,n);if(!r.resolved)throw failure(`path ${JSON.stringify(e)} could not be resolved in original object`);applyPatches(this.originalData,[{path:e,op:"replace",value:getSnapshot(t.value)}])}reset(){applySnapshot(this.data,this.originalSnapshot)}resetByPath(e){let t=resolvePath(this.originalData,e);if(!t.resolved)throw failure(`path ${JSON.stringify(e)} could not be resolved in original object`);let n=pathToTargetPathIdsIgnoringLast(this.originalData,e),r=resolvePathCheckingIds(this.data,e,n);if(!r.resolved)throw failure(`path ${JSON.stringify(e)} could not be resolved in draft object`);applyPatches(this.data,[{path:e,op:"replace",value:getSnapshot(t.value)}])}get isDirty(){return!deepEquals(getSnapshot(this.data),this.originalSnapshot)}isDirtyByPath(e){let t=resolvePath(this.data,e);if(!t.resolved)throw failure(`path ${JSON.stringify(e)} could not be resolved in draft object`);let n=pathToTargetPathIdsIgnoringLast(this.data,e),r=resolvePathCheckingIds(this.originalData,e,n);return!r.resolved||!deepEquals(t.value,r.value)}get originalSnapshot(){return getSnapshot(this.originalData)}};function draft(e){return new Draft(e)}function pathToTargetPathIdsIgnoringLast(e,t){let n=function(e,t){var n;let r=[],o=e;for(let e=0;e<t.length;e++){o=o[t[e]];let a=isModel(o)&&null!=(n=o[E])?n:null;r.push(a)}return r}(e,t);return n.length>=1&&(n[n.length-1]=tg),n}__decorate([N.action],Draft.prototype,"commit",null),__decorate([N.action],Draft.prototype,"commitByPath",null),__decorate([N.action],Draft.prototype,"reset",null),__decorate([N.action],Draft.prototype,"resetByPath",null),__decorate([N.computed],Draft.prototype,"isDirty",null),__decorate([N.computed],Draft.prototype,"originalSnapshot",null),new ContextClass(void 0);let tW=class extends Model({[E]:ed,items:tProp(typesArray(typesUnchecked()),()=>[])}){add(e){let t=this.items;return t.includes(e)||t.push(e),this}clear(){this.items.length=0}delete(e){let t=this.items,n=t.findIndex(t=>t===e);return n>=0&&(t.splice(n,1),!0)}forEach(e,t){let n=this.items,r=n.length;for(let o=0;o<r;o++){let r=n[o];e.call(t,r,r,this)}}has(e){return this.items.includes(e)}get size(){return this.items.length}keys(){return this.values()}values(){let e=this.items;return(0,N.values)(e)[Symbol.iterator]()}entries(){let e=this.items;return e.map(e=>[e,e]).values()}[Symbol.iterator](){return this.values()}get[Symbol.toStringTag](){return"ArraySet"}};function typesRecord(e){let typeInfoGen=t=>new RecordTypeInfo(t,resolveStandardType(e));return lateTypeChecker(()=>{let t=resolveTypeChecker(e),getTypeName=(...e)=>`Record<${t.getTypeName(...e,t)}>`,applySnapshotProcessor=(e,n)=>{if(t.unchecked)return e;let r={},o=Object.keys(e);for(let a=0;a<o.length;a++){let l=o[a],i="from"===n?t.fromSnapshotProcessor(e[l]):t.toSnapshotProcessor(e[l]);r[l]=i}return r},n=new TypeChecker(C.Object,(e,r,o)=>{if(!isObject(e))return new TypeCheckError(r,getTypeName(n),e,o);if(!t.unchecked){let n=Object.keys(e);for(let a=0;a<n.length;a++){let l=n[a],i=e[l],s=t.check(i,[...r,l],o);if(s)return s}}return null},getTypeName,typeInfoGen,e=>{if(!isObject(e))return null;if(!t.unchecked){let n=Object.keys(e);for(let r=0;r<n.length;r++){let o=n[r],a=e[o],l=t.snapshotType(a);if(!l)return null}}return n},e=>applySnapshotProcessor(e,"from"),e=>applySnapshotProcessor(e,"to"));return n},typeInfoGen)}__decorate([modelAction],tW.prototype,"add",null),__decorate([modelAction],tW.prototype,"clear",null),__decorate([modelAction],tW.prototype,"delete",null),tW=__decorate([model(`${Q}/ArraySet`)],tW);let RecordTypeInfo=class RecordTypeInfo extends TypeInfo{constructor(e,t){super(e),__publicField(this,"valueType"),this.valueType=t}get valueTypeInfo(){return getTypeInfo(this.valueType)}};let tJ=class extends Model({[E]:ed,items:tProp(typesRecord(typesUnchecked()),()=>({}))}){clear(){let e=this.items,t=Object.keys(e),n=t.length;for(let r=0;r<n;r++){let n=t[r];(0,N.remove)(e,n)}}delete(e){let t=this.has(e);return!!t&&((0,N.remove)(this.items,e),!0)}forEach(e,t){let n=this.items,r=Object.keys(n),o=r.length;for(let a=0;a<o;a++){let o=r[a];e.call(t,n[o],o,this)}}get(e){return(0,N.get)(this.items,e)}has(e){return(0,N.has)(this.items,e)}set(e,t){return setIfDifferent(this.items,e,t),this}get size(){return(0,N.keys)(this.items).length}keys(){return(0,N.keys)(this.items)[Symbol.iterator]()}values(){return(0,N.values)(this.items)[Symbol.iterator]()}entries(){return(0,N.entries)(this.items)[Symbol.iterator]()}[Symbol.iterator](){return this.entries()}get[Symbol.toStringTag](){return"ObjectMap"}};function typesRefinement(e,t,n){let typeInfoGen=r=>new RefinementTypeInfo(r,resolveStandardType(e),t,n);return lateTypeChecker(()=>{let r=resolveTypeChecker(e),getTypeName=(...e)=>{let t=r.getTypeName(...e,r),o=n||"refinementOf";return`${o}<${t}>`},o=new TypeChecker(r.baseType,(e,n,a)=>{let l=r.check(e,n,a);if(l)return l;let i=t(e);return!0===i||null==i?null:!1===i?new TypeCheckError(n,getTypeName(o),e,a):new TypeCheckError(i.path,i.expectedTypeName,i.actualValue,a)},getTypeName,typeInfoGen,e=>r.snapshotType(e),e=>r.fromSnapshotProcessor(e),e=>r.toSnapshotProcessor(e));return o},typeInfoGen)}__decorate([modelAction],tJ.prototype,"clear",null),__decorate([modelAction],tJ.prototype,"delete",null),__decorate([modelAction],tJ.prototype,"set",null),tJ=__decorate([model(`${Q}/ObjectMap`)],tJ);let RefinementTypeInfo=class RefinementTypeInfo extends TypeInfo{constructor(e,t,n,r){super(e),__publicField(this,"baseType"),__publicField(this,"checkFunction"),__publicField(this,"typeName"),this.baseType=t,this.checkFunction=n,this.typeName=r}get baseTypeInfo(){return getTypeInfo(this.baseType)}};typesRefinement(e_,e=>Number.isInteger(e),"integer"),typesRefinement(ek,e=>""!==e,"nonEmpty")}}]);